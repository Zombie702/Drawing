<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Universal Drawing - Social Feed</title>
    
    <link rel="manifest" id="my-manifest-placeholder">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/1048/1048950.png">
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@300;400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f172a', // Slate 900
                            surface: '#1e293b', // Slate 800
                            accent: '#6366f1' // Indigo 500
                        }
                    },
                    animation: {
                        'float': 'float 6s ease-in-out infinite',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        glow: {
                            'from': { boxShadow: '0 0 10px #6366f1, 0 0 20px #6366f1' },
                            'to': { boxShadow: '0 0 20px #818cf8, 0 0 30px #818cf8' },
                        }
                    }
                }
            }
        }
    </script>

    <script>
        const manifest={name:"Universal Drawing",short_name:"U-Draw",start_url:".",display:"standalone",background_color:"#0f172a",theme_color:"#0f172a",orientation:"portrait",icons:[{src:"https://cdn-icons-png.flaticon.com/512/1048/1048950.png",sizes:"192x192",type:"image/png"},{src:"https://cdn-icons-png.flaticon.com/512/1048/1048950.png",sizes:"512x512",type:"image/png"}]};
        const blob=new Blob([JSON.stringify(manifest)],{type:'application/json'});
        document.querySelector('#my-manifest-placeholder').setAttribute('href', URL.createObjectURL(blob));
    </script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, addDoc, getDoc, updateDoc, deleteDoc, collection, onSnapshot, getDocs, query, where, orderBy, writeBatch, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCLO2HKD2HbdgdD85aCyHrijCotNx5hSbQ",
            authDomain: "universal-drawing.firebaseapp.com",
            projectId: "universal-drawing",
            storageBucket: "universal-drawing.firebasestorage.app",
            messagingSenderId: "1054486672632",
            appId: "1:1054486672632:web:652fb4cd8124b9e403370d",
            measurementId: "G-03B7K7H1W1"
        };

        try {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);
            
            window.firebaseData = { 
                auth, db, 
                doc, setDoc, addDoc, getDoc, updateDoc, deleteDoc, collection, onSnapshot, getDocs, query, where, orderBy, writeBatch, arrayUnion, arrayRemove,
                createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updateProfile, 
                onAuthStateChanged 
            };
        } catch (e) { console.error("Firebase Error:", e); }
    </script>

    <style>
        body { 
            font-family: 'Tajawal', sans-serif; 
            background: radial-gradient(circle at top, #1e293b, #0f172a);
            background-color: #0f172a; 
            color: #f8fafc;
            overflow: hidden; 
            overscroll-behavior: none;
            user-select: none; /* Globally disable text selection */
            -webkit-user-select: none;
        }
        
        /* Glassmorphism Classes */
        .glass {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .glass-heavy {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
        }
        
        /* Letterbox Canvas Container */
        .canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: transparent;
            overflow: hidden;
            position: relative;
        }

        canvas.main-canvas {
            aspect-ratio: 9 / 16;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            background-color: white;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 4px;
            touch-action: none;
            cursor: crosshair;
        }

        [v-cloak] { display: none !important; }
        
        .pattern-lock-wrapper { width: 280px; height: 280px; position: relative; margin: 10px auto; background: rgba(255,255,255,0.05); border-radius: 20px; direction: ltr !important; }
        .pattern-canvas { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 20; }
        .dots-container { display: grid; grid-template-columns: repeat(3, 1fr); width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        .dot-cell { display: flex; align-items: center; justify-content: center; }
        .dot { width: 18px; height: 18px; background: rgba(255,255,255,0.4); border-radius: 50%; transition: all 0.3s ease; }
        .dot.active { background: #6366f1; box-shadow: 0 0 15px #6366f1; transform: scale(1.4); }

        .slide-up-enter-active, .slide-up-leave-active { transition: transform 0.3s ease; }
        .slide-up-enter-from, .slide-up-leave-to { transform: translateY(100%); }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.2s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        
        .paired-pulse { animation: greenPulse 2s infinite; }
        @keyframes greenPulse { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }

        .rainbow-btn {
            background: conic-gradient(red, yellow, lime, aqua, blue, magenta, red);
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        input[type=range] {
            height: 4px;
            -webkit-appearance: none;
            margin: 10px 0;
            width: 100%;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
            border: 2px solid white;
        }
        
        /* Color Picker Styles */
        .color-picker-sv {
            position: relative;
            width: 100%;
            height: 200px;
            background-color: red;
            border-radius: 12px;
            cursor: crosshair;
            overflow: hidden;
            touch-action: none;
        }
        .sv-white { position: absolute; inset: 0; background: linear-gradient(to right, #fff, rgba(255,255,255,0)); }
        .sv-black { position: absolute; inset: 0; background: linear-gradient(to top, #000, rgba(0,0,0,0)); }
        .picker-cursor {
            position: absolute;
            width: 16px; height: 16px;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Bottom Nav Item Active State */
        .nav-item.active i {
            color: #6366f1;
            transform: translateY(-5px);
            text-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }
        .nav-item.active span {
            color: #fff;
            opacity: 1;
        }

        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-[#0f172a] text-white">

<div id="app" v-cloak class="fixed inset-0 w-full h-full flex flex-col">

    <!-- Background Elements -->
    <div class="fixed top-[-10%] left-[-10%] w-[50%] h-[50%] bg-indigo-900/30 rounded-full blur-[100px] pointer-events-none"></div>
    <div class="fixed bottom-[-10%] right-[-10%] w-[50%] h-[50%] bg-purple-900/30 rounded-full blur-[100px] pointer-events-none"></div>

    <!-- Loading Screen -->
    <div v-if="isLoading" class="absolute inset-0 z-[6000] bg-[#0f172a] flex flex-col items-center justify-center p-5">
        <div class="w-16 h-16 border-4 border-indigo-500/30 border-t-indigo-500 rounded-full animate-spin"></div>
        <p class="mt-4 text-indigo-300 font-bold animate-pulse">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</p>
    </div>

    <!-- Toast Notification -->
    <transition name="toast">
        <div v-if="toast.show" class="fixed top-10 left-1/2 transform -translate-x-1/2 z-[6000] glass text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-3 min-w-[200px] justify-center transition-all duration-300 border border-indigo-500/30">
            <i :class="toast.icon" class="text-indigo-400"></i><span class="font-bold text-sm">{{ toast.message }}</span>
        </div>
    </transition>

    <!-- App Lock Overlay -->
    <div v-if="isAppLocked && user" class="fixed inset-0 z-[5250] bg-[#0f172a] flex flex-col items-center justify-center text-white p-4">
        <div class="mb-4 text-center animate-float"><div class="w-20 h-20 glass rounded-full flex items-center justify-center mx-auto mb-4 border border-indigo-500/30 shadow-[0_0_30px_rgba(99,102,241,0.3)]"><i class="fas fa-lock text-3xl text-indigo-400"></i></div><h2 class="text-2xl font-bold">Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ù‚ÙÙ„</h2></div>
        <div class="pattern-lock-wrapper" @touchstart="startPattern" @touchmove="movePattern" @touchend="endPattern" @mousedown="startPattern" @mousemove="movePattern" @mouseup="endPattern"><canvas ref="lockCanvas" width="280" height="280" class="pattern-canvas"></canvas><div class="dots-container"><div v-for="n in 9" :key="n" class="dot-cell"><div class="dot" :class="{'active': currentPattern.includes(n-1)}"></div></div></div></div>
        <p v-if="lockError" class="text-red-400 font-bold mt-4 animate-pulse">{{ lockError }}</p>
    </div>

    <!-- Login Screen -->
    <div v-if="!user && !isLoading" class="absolute inset-0 z-[5000] bg-[#0f172a] flex flex-col items-center justify-center p-6 text-white">
        <div class="w-32 h-32 bg-gradient-to-tr from-indigo-500 to-purple-500 rounded-3xl flex items-center justify-center mb-6 shadow-[0_0_50px_rgba(99,102,241,0.5)] animate-float">
            <i class="fas fa-paint-brush text-5xl text-white"></i>
        </div>
        <h1 class="text-4xl font-black mb-2">Universal Drawing</h1>
        <p class="text-indigo-300 mb-10 text-sm">Ù…Ø³Ø§Ø­ØªÙƒ Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ© Ø§Ù„Ø­Ø±Ø©</p>
        
        <div class="w-full max-w-sm glass p-8 rounded-3xl shadow-2xl">
            <form @submit.prevent="handleQuickLogin" class="flex flex-col gap-5">
                <div>
                    <label class="text-xs text-gray-400 mr-2 mb-1 block font-bold">Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</label>
                    <input v-model="loginName" type="text" placeholder="Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ Ù‡Ù†Ø§..." required class="w-full p-4 rounded-xl bg-black/20 border border-white/10 text-white text-right placeholder-gray-500 focus:border-indigo-500 focus:outline-none transition">
                </div>
                <p v-if="errorMsg" class="text-red-400 text-xs text-center font-bold bg-red-900/20 p-2 rounded-lg">{{ errorMsg }}</p>
                <button type="submit" :disabled="isLoggingIn" class="bg-gradient-to-r from-indigo-600 to-indigo-500 text-white font-bold py-4 rounded-xl hover:shadow-[0_0_20px_rgba(99,102,241,0.4)] transition transform active:scale-95 w-full flex items-center justify-center gap-2">
                    <span v-if="isLoggingIn" class="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin"></span>
                    <span v-else>Ø¯Ø®ÙˆÙ„ <i class="fas fa-rocket mr-2"></i></span>
                </button>
            </form>
        </div>
    </div>

    <!-- Main App Content -->
    <template v-else-if="user">
        
        <!-- --- HOME PAGE (Feed) --- -->
        <div v-if="currentView === 'home'" class="flex-1 overflow-y-auto p-4 pb-24 custom-scroll relative z-10">
            <!-- Header -->
            <header class="flex justify-between items-center mb-6 px-2">
                <h1 class="text-2xl font-black text-white flex items-center gap-2">
                    <span class="bg-clip-text text-transparent bg-gradient-to-l from-indigo-400 to-purple-500">Universal</span>
                    <i class="fas fa-bolt text-yellow-400"></i>
                </h1>
                <div class="flex items-center gap-3">
                     <!-- Memories/Feed Icon (Now redundant as we are on home, but kept for visual balance or refresh) -->
                     <button @click="switchView('home')" class="w-10 h-10 rounded-full glass flex items-center justify-center text-white hover:bg-white/10 transition border border-white/10">
                        <i class="fas fa-home"></i>
                    </button>
                </div>
            </header>

            <!-- Stories / Friends Strip -->
            <div class="mb-6">
                 <div class="flex gap-4 overflow-x-auto pb-2 scrollbar-hide px-2">
                    <!-- My Story (Add) -->
                    <div class="flex flex-col items-center gap-2 min-w-[70px] cursor-pointer group" @click="triggerCamera">
                        <div class="w-16 h-16 rounded-full glass border-2 border-dashed border-indigo-400 flex items-center justify-center text-indigo-400 relative">
                             <img v-if="userData.photoURL" :src="userData.photoURL" class="w-full h-full rounded-full object-cover opacity-50">
                             <i class="fas fa-plus text-xl absolute z-10"></i>
                        </div>
                        <span class="text-xs font-bold text-indigo-300">Ù‚ØµØªÙŠ</span>
                    </div>

                    <!-- Friend Stories -->
                    <div v-for="u in onlineUsers" :key="u.id" @click="openSessionSetup(u)" class="flex flex-col items-center gap-2 min-w-[70px] cursor-pointer group">
                        <div class="w-16 h-16 rounded-full glass border-2 border-transparent group-hover:border-indigo-500 transition overflow-hidden relative p-[2px] bg-gradient-to-tr from-indigo-500 to-purple-500">
                             <div class="w-full h-full rounded-full bg-black overflow-hidden relative">
                                <img v-if="u.photoURL" :src="u.photoURL" class="w-full h-full object-cover">
                                <span v-else class="w-full h-full flex items-center justify-center font-bold text-lg">{{ u.name.charAt(0) }}</span>
                             </div>
                            <div class="absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-[#0f172a]" 
                                 :class="isUserOnline(u) ? 'bg-green-500' : 'bg-gray-500'"></div>
                        </div>
                        <span class="text-xs text-gray-300 truncate w-full text-center">{{ u.name }}</span>
                    </div>
                </div>
            </div>

            <!-- Social Feed -->
            <div class="space-y-6">
                 <div v-if="memoryFeed.length === 0" class="glass p-10 rounded-3xl text-center border border-white/5 mx-2">
                    <div class="w-20 h-20 bg-white/5 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
                        <i class="fas fa-camera text-3xl text-gray-500"></i>
                    </div>
                    <h3 class="font-bold text-lg text-white mb-2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†Ø´ÙˆØ±Ø§Øª</h3>
                    <p class="text-sm text-gray-400">ÙƒÙ† Ø£ÙˆÙ„ Ù…Ù† ÙŠØ´Ø§Ø±Ùƒ Ø±Ø³Ù…Ø© Ø£Ùˆ ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡!</p>
                    <button @click="triggerCamera" class="mt-4 bg-indigo-600 text-white px-6 py-2 rounded-full font-bold text-sm">Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø´ÙˆØ±</button>
                 </div>

                 <!-- Post Card -->
                 <div v-for="post in memoryFeed" :key="post.id" class="glass rounded-3xl overflow-hidden border border-white/5 shadow-xl mx-2">
                    <!-- Post Header -->
                    <div class="p-4 flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 rounded-full bg-indigo-500/20 flex items-center justify-center overflow-hidden border border-white/10">
                                <img v-if="post.userPhoto" :src="post.userPhoto" class="w-full h-full object-cover">
                                <span v-else class="text-indigo-300 font-bold">{{ post.senderName.charAt(0) }}</span>
                            </div>
                            <div>
                                <h4 class="font-bold text-sm text-white">{{ post.senderName }}</h4>
                                <span class="text-[10px] text-gray-400">{{ formatDateHeader(post.timestamp) }}</span>
                            </div>
                        </div>
                        <button class="text-gray-400 hover:text-white"><i class="fas fa-ellipsis-h"></i></button>
                    </div>

                    <!-- Post Image -->
                    <div class="w-full bg-black/40 relative">
                        <img :src="post.imageUrl" class="w-full h-auto object-contain max-h-[500px]" loading="lazy" @click="viewImage(post.imageUrl, post.senderName)">
                    </div>

                    <!-- Post Actions -->
                    <div class="p-4">
                        <div class="flex items-center gap-4 mb-3">
                            <button @click="toggleLike(post)" class="text-2xl transition transform active:scale-90" :class="post.isLiked ? 'text-red-500' : 'text-white hover:text-gray-300'">
                                <i :class="post.isLiked ? 'fas fa-heart' : 'far fa-heart'"></i>
                            </button>
                            <button class="text-2xl text-white hover:text-gray-300"><i class="far fa-comment"></i></button>
                            <button class="text-2xl text-white hover:text-gray-300 ml-auto"><i class="far fa-bookmark"></i></button>
                        </div>
                        
                        <p class="text-sm font-bold text-white mb-2" v-if="post.likes && post.likes.length > 0">{{ post.likes.length }} Ø¥Ø¹Ø¬Ø§Ø¨</p>
                        
                        <!-- Caption/Comments -->
                        <div class="space-y-1 mb-3">
                            <div v-for="(comment, idx) in (post.comments || []).slice(-3)" :key="idx" class="text-sm">
                                <span class="font-bold text-white ml-2">{{ comment.userName }}</span>
                                <span class="text-gray-300">{{ comment.text }}</span>
                            </div>
                        </div>

                        <!-- Add Comment -->
                        <form @submit.prevent="addComment(post)" class="flex items-center gap-3 mt-2">
                             <div class="w-6 h-6 rounded-full bg-gray-700 overflow-hidden flex-shrink-0">
                                 <img v-if="userData.photoURL" :src="userData.photoURL" class="w-full h-full object-cover">
                                 <div v-else class="w-full h-full bg-indigo-500"></div>
                             </div>
                             <input v-model="post.newComment" type="text" placeholder="Ø£Ø¶Ù ØªØ¹Ù„ÙŠÙ‚Ø§Ù‹..." class="flex-1 bg-transparent text-sm text-white focus:outline-none placeholder-gray-500">
                             <button type="submit" :disabled="!post.newComment" class="text-indigo-400 font-bold text-sm disabled:opacity-50">Ù†Ø´Ø±</button>
                        </form>
                    </div>
                 </div>
            </div>
        </div>

        <!-- --- CANVAS PAGE --- -->
        <div v-show="currentView === 'canvas'" class="flex-1 flex flex-col h-full relative z-10">
            <!-- Canvas Header -->
            <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-[50] pointer-events-none">
                 <!-- Mode Switcher -->
                <div class="pointer-events-auto bg-black/60 backdrop-blur-md rounded-2xl p-1 flex gap-1 border border-white/10 shadow-lg">
                    <button @click="switchMode('draw')" :class="{'bg-indigo-600 text-white shadow': mode === 'draw', 'text-gray-400 hover:text-white': mode !== 'draw'}" class="px-4 py-2 rounded-xl text-sm font-bold transition">Ø±Ø³Ù…</button>
                    <button @click="switchMode('color')" :class="{'bg-indigo-600 text-white shadow': mode === 'color', 'text-gray-400 hover:text-white': mode !== 'color'}" class="px-4 py-2 rounded-xl text-sm font-bold transition">ØªÙ„ÙˆÙŠÙ†</button>
                    <button @click="switchMode('image')" :class="{'bg-indigo-600 text-white shadow': mode === 'image', 'text-gray-400 hover:text-white': mode !== 'image'}" class="px-4 py-2 rounded-xl text-sm font-bold transition">ØµÙˆØ±Ø©</button>
                </div>

                <!-- Session Status -->
                <button @click="openPairingModal" class="pointer-events-auto w-10 h-10 rounded-full glass flex items-center justify-center shadow-lg border border-white/10" :class="pairing.isPaired ? 'text-green-400 paired-pulse border-green-500/30' : 'text-gray-400'">
                    <i class="fas" :class="pairing.isPaired ? 'fa-link' : 'fa-unlink'"></i>
                </button>
            </div>

            <!-- Magic Wand Button -->
            <button v-if="mode === 'color'" @click="showMagicModal = true" class="absolute top-20 left-4 z-[45] pointer-events-auto glass w-12 h-12 rounded-full flex items-center justify-center text-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.3)] hover:scale-110 transition border border-yellow-500/20">
                <i class="fas fa-magic text-xl"></i>
            </button>
            
            <!-- Trash Button for Generated Image -->
            <button v-if="mode === 'color' && coloringBaseImage" @click="deleteGeneratedImage" class="absolute top-20 left-20 z-[45] pointer-events-auto glass w-12 h-12 rounded-full flex items-center justify-center text-red-400 shadow-lg hover:bg-red-500/20 transition border border-red-500/20">
                <i class="fas fa-trash-alt"></i>
            </button>

            <!-- Main Canvas Area -->
            <div :class="isFullscreen ? 'fixed inset-0 z-[100] bg-[#0f172a]' : 'flex-1 relative w-full overflow-hidden'" ref="drawingContainer">
                <!-- Controls -->
                <div v-if="mode === 'draw' || mode === 'color'" class="absolute top-20 right-4 z-[45] flex flex-col gap-2 pointer-events-auto" :class="{'top-4': isFullscreen}">
                    <button @click="toggleFullscreen" class="glass w-10 h-10 rounded-full flex items-center justify-center text-white hover:bg-white/10 transition"><i class="fas" :class="isFullscreen ? 'fa-compress' : 'fa-expand'"></i></button>
                    <button @click="resetView" class="glass w-10 h-10 rounded-full flex items-center justify-center text-white hover:bg-white/10 transition"><i class="fas fa-compress-arrows-alt"></i></button>
                    
                    <div class="h-px w-full bg-white/10 my-1"></div>
                    
                    <button @click="undo" :disabled="localActionIds.length === 0" class="glass w-10 h-10 rounded-full flex items-center justify-center text-white hover:bg-white/10 transition disabled:opacity-30"><i class="fas fa-undo"></i></button>
                    <button @click="redo" :disabled="redoStack.length === 0" class="glass w-10 h-10 rounded-full flex items-center justify-center text-white hover:bg-white/10 transition disabled:opacity-30"><i class="fas fa-redo"></i></button>
                    
                    <div class="h-px w-full bg-white/10 my-1"></div>
                    
                    <button @click="showConfirm('Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©', 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù… Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŸ', 'fas fa-trash-alt', clearCanvas)" class="glass w-10 h-10 rounded-full flex items-center justify-center text-red-400 hover:bg-red-500/20 transition"><i class="fas fa-trash"></i></button>
                </div>

                <!-- Canvas Element -->
                <div v-show="mode === 'draw' || mode === 'color'" class="canvas-container">
                    <div :style="{ transform: 'translate(' + panX + 'px, ' + panY + 'px) scale(' + zoomLevel + ')' }" class="w-full h-full flex items-center justify-center origin-center will-change-transform">
                        <canvas ref="canvas" width="1080" height="1920"
                                @mousedown="handleStart" @mousemove="handleMove" @mouseup="handleEnd" 
                                @touchstart="handleStart" @touchmove="handleMove" @touchend="handleEnd" 
                                class="main-canvas block"></canvas>
                    </div>
                </div>

                <!-- Image Upload Mode -->
                <div v-show="mode === 'image'" class="w-full h-full flex flex-col items-center justify-center relative p-4">
                    <img v-if="uploadedImage" :src="uploadedImage" class="absolute inset-0 w-full h-full object-contain p-4 z-10">
                    <button v-if="uploadedImage" @click.stop="removeImage" class="absolute top-20 right-4 z-50 bg-red-600 text-white rounded-full w-10 h-10 shadow-lg flex items-center justify-center"><i class="fas fa-times"></i></button>
                    <div v-if="!uploadedImage" class="text-center p-10 border-2 border-dashed border-white/20 rounded-3xl glass w-full max-w-sm flex flex-col items-center">
                        <i class="fas fa-cloud-upload-alt text-4xl text-indigo-400 mb-4"></i>
                        <p class="font-bold text-gray-300">Ø§Ø¶ØºØ· Ù„Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø©</p>
                    </div>
                    <input v-if="!uploadedImage" type="file" @change="handleImageUpload" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20" ref="imageUploadInput">
                    <button v-if="uploadedImage" @click="openFriendSelector" class="absolute bottom-24 bg-indigo-600 text-white px-8 py-3 rounded-xl shadow-xl font-bold z-50 flex items-center gap-2 hover:bg-indigo-700 transition"><span>Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©</span> <i class="fas fa-paper-plane"></i></button>
                </div>

                <!-- AI Loading Overlay -->
                <div v-if="isGeneratingAI" class="absolute inset-0 z-[100] bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center">
                    <div class="relative">
                         <div class="w-20 h-20 border-4 border-indigo-500 rounded-full animate-ping absolute top-0 left-0 opacity-20"></div>
                         <i class="fas fa-magic text-4xl text-indigo-400 animate-pulse"></i>
                    </div>
                    <p class="font-bold text-white mt-8 text-lg">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...</p>
                </div>
            </div>

            <!-- Tools Toolbar Container with Toggle -->
            <div v-if="mode !== 'image' && !isWaitingForAccept" 
                 class="absolute bottom-[90px] left-1/2 transform -translate-x-1/2 z-[50] w-[95%] max-w-[400px] transition-transform duration-300 ease-in-out"
                 :class="{ 'translate-y-[120%]': isToolsCollapsed }">
                
                <!-- Toggle Arrow Button -->
                 <button @click="isToolsCollapsed = !isToolsCollapsed" 
                         class="absolute -top-10 left-1/2 -translate-x-1/2 w-12 h-8 rounded-t-xl glass-heavy flex items-center justify-center border-t border-x border-white/10 text-gray-400 hover:text-white transition shadow-lg">
                    <i class="fas transition-transform duration-300" :class="isToolsCollapsed ? 'fa-chevron-up' : 'fa-chevron-down'"></i>
                </button>

                <div class="glass-heavy rounded-2xl p-2 flex items-center justify-between shadow-2xl border border-white/10">
                    
                    <!-- Main Tools (Unified for Draw & Color) -->
                    <div class="flex gap-2 items-center">
                        <button @click="activatePen" :class="!isBucket && !isEraser ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-500/50' : 'text-gray-400 hover:bg-white/10'" class="w-10 h-10 rounded-xl flex items-center justify-center transition"><i class="fas fa-pen"></i></button>
                        <button @click="activateBucket" :class="isBucket ? 'bg-pink-500 text-white shadow-lg shadow-pink-500/50' : 'text-gray-400 hover:bg-white/10'" class="w-10 h-10 rounded-xl flex items-center justify-center transition"><i class="fas fa-fill-drip"></i></button>
                        <button @click="activateEraser" :class="isEraser ? 'bg-indigo-600 text-white shadow-lg' : 'text-gray-400 hover:bg-white/10'" class="w-10 h-10 rounded-xl flex items-center justify-center transition"><i class="fas fa-eraser"></i></button>
                        
                        <!-- Brush Size -->
                         <div class="relative">
                            <button @click.stop="toggleBrushPopup" class="w-10 h-10 rounded-xl bg-white/5 flex items-center justify-center border border-white/10">
                                <div class="rounded-full bg-white" :style="{ width: Math.min(brushSize, 16) + 'px', height: Math.min(brushSize, 16) + 'px' }"></div>
                            </button>
                            <div v-if="showBrushPopup" class="absolute bottom-full left-0 mb-3 glass p-3 rounded-xl w-48 flex items-center gap-2" @click.stop>
                                <input type="range" v-model="brushSize" min="1" max="40" class="flex-1">
                                <span class="text-xs font-bold w-6">{{ brushSize }}</span>
                            </div>
                        </div>
                    </div>

                    <div class="w-px h-8 bg-white/10 mx-1"></div>

                    <!-- Colors (Custom Picker Only) -->
                    <div class="flex gap-2 items-center px-1">
                         <div @click="openColorPicker" class="w-10 h-10 rounded-full rainbow-btn shrink-0 cursor-pointer flex items-center justify-center shadow-lg"><i class="fas fa-palette text-sm text-white drop-shadow-md"></i></div>
                         <div class="w-8 h-8 rounded-full border-2 border-white shadow-inner transition" :style="{ backgroundColor: brushColor }"></div>
                    </div>

                    <!-- Send Action -->
                    <button @click="openFriendSelector" class="w-10 h-10 rounded-xl bg-indigo-600 text-white flex items-center justify-center shadow-lg shadow-indigo-600/30 hover:bg-indigo-500 transition ml-2 shrink-0">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- --- CHAT PAGE --- -->
        <div v-if="currentView === 'chat'" class="flex-1 flex flex-col h-full overflow-hidden relative z-10 bg-[#0f172a]">
             <div v-if="!selectedChatFriend" class="p-4 overflow-y-auto h-full pb-24">
                <h2 class="text-2xl font-bold mb-6 px-2">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª</h2>
                <div v-if="chatList.length === 0" class="text-center py-20 opacity-50"><i class="fas fa-comment-slash text-4xl mb-2"></i><p>Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£ØµØ¯Ù‚Ø§Ø¡ Ù…ØªØµÙ„ÙŠÙ†</p></div>
                <div class="grid gap-3">
                     <div v-for="friend in chatList" :key="friend.id" @click="selectChatFriend(friend)" class="glass p-4 rounded-xl flex items-center gap-4 cursor-pointer hover:bg-white/10 transition group border border-white/5">
                         <div class="w-14 h-14 rounded-full bg-indigo-500/20 flex items-center justify-center text-indigo-300 font-bold text-xl border border-indigo-500/30 group-hover:border-indigo-500 transition overflow-hidden">
                             <img v-if="friend.photoURL" :src="friend.photoURL" class="w-full h-full object-cover">
                             <span v-else>{{ friend.name.charAt(0) }}</span>
                         </div>
                         <div class="flex-1">
                             <h3 class="font-bold text-lg text-white">{{ friend.name }}</h3>
                             <p class="text-xs text-gray-400">Ø§Ø¶ØºØ· Ù„Ù„Ù…Ø±Ø§Ø³Ù„Ø©...</p>
                         </div>
                         <i class="fas fa-chevron-left text-gray-500 group-hover:text-indigo-400 transition"></i>
                     </div>
                </div>
            </div>
            <div v-else class="flex flex-col h-full pb-20">
                <header class="glass-heavy p-4 flex items-center gap-4 shrink-0 z-20">
                    <button @click="selectedChatFriend = null" class="w-10 h-10 rounded-full hover:bg-white/10 flex items-center justify-center transition"><i class="fas fa-arrow-right"></i></button>
                    <div class="w-10 h-10 rounded-full bg-indigo-500 flex items-center justify-center font-bold overflow-hidden">
                         <img v-if="selectedChatFriend.photoURL" :src="selectedChatFriend.photoURL" class="w-full h-full object-cover">
                         <span v-else>{{ selectedChatFriend.name.charAt(0) }}</span>
                    </div>
                    <h3 class="font-bold text-lg">{{ selectedChatFriend.name }}</h3>
                </header>
                <div class="flex-1 overflow-y-auto p-4 space-y-4 custom-scroll" ref="chatContainer">
                    <div v-for="msg in currentChatMessages" :key="msg.id" class="flex flex-col w-full" :class="msg.senderId === user.uid ? 'items-end' : 'items-start'">
                        <div class="max-w-[75%] rounded-2xl overflow-hidden shadow-lg border border-white/10" :class="msg.senderId === user.uid ? 'bg-indigo-600 rounded-br-none' : 'bg-gray-700 rounded-bl-none'">
                            <img :src="msg.imageUrl" @click="viewImage(msg.imageUrl, msg.senderId === user.uid ? 'Ø£Ù†Øª' : selectedChatFriend.name)" class="w-full h-auto object-cover max-h-80 min-w-[150px] bg-black/20 cursor-pointer">
                        </div>
                        <span class="text-[10px] text-gray-400 mt-1 mx-1">{{ new Date(msg.timestamp).toLocaleTimeString('ar-EG', {hour: '2-digit', minute:'2-digit'}) }}</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- --- PROFILE PAGE --- -->
        <div v-if="currentView === 'profile'" class="flex-1 overflow-y-auto p-6 pb-24 custom-scroll relative z-10">
             
            <!-- Profile Header with Settings Button -->
            <div class="flex justify-between items-center mb-6">
                 <h1 class="text-3xl font-bold">Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</h1>
                 <button @click="openSettings" class="w-12 h-12 rounded-full glass flex items-center justify-center text-blue-400 hover:bg-white/10 transition border border-white/10">
                    <i class="fas fa-cog text-xl"></i>
                </button>
            </div>

            <div class="flex flex-col items-center mb-8">
                <div class="w-32 h-32 rounded-full bg-gradient-to-tr from-indigo-500 to-pink-500 p-1 mb-3 shadow-[0_0_30px_rgba(99,102,241,0.3)] relative group">
                    <div class="w-full h-full rounded-full bg-[#1e293b] flex items-center justify-center text-3xl font-bold overflow-hidden relative">
                         <img v-if="userData.photoURL" :src="userData.photoURL" class="w-full h-full object-cover">
                         <span v-else>{{ userData.name?.charAt(0) }}</span>
                         
                         <!-- Edit Photo Overlay -->
                         <div @click="triggerProfileUpload" class="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition cursor-pointer">
                             <i class="fas fa-camera text-white text-2xl"></i>
                         </div>
                    </div>
                    <input type="file" ref="profileInput" @change="handleProfileUpload" accept="image/*" class="hidden">
                </div>
                <h2 class="text-2xl font-bold">{{ userData.name }}</h2>
                <p class="text-gray-400 text-sm">{{ userData.email }}</p>
                <div class="mt-2 bg-white/5 px-3 py-1 rounded-full text-xs text-gray-400 border border-white/5">{{ getDeviceInfo() }}</div>
            </div>

            <!-- Stats Grid -->
             <div class="grid grid-cols-2 gap-4 mb-8">
                 <div class="glass p-4 rounded-xl text-center border border-white/10">
                     <i class="fas fa-fire text-orange-400 text-2xl mb-2"></i>
                     <p class="text-2xl font-bold text-white">{{ userData.streak || 0 }}</p>
                     <p class="text-xs text-gray-400">Ø³ØªØ±ÙŠÙƒ</p>
                 </div>
                 <div class="glass p-4 rounded-xl text-center border border-white/10">
                     <i class="fas fa-star text-yellow-400 text-2xl mb-2"></i>
                     <p class="text-2xl font-bold text-white">{{ userData.dailyRating?.stars || 0 }}</p>
                     <p class="text-xs text-gray-400">ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙŠÙˆÙ…</p>
                 </div>
             </div>
        </div>

        <!-- --- BOTTOM NAVIGATION --- -->
        <nav class="fixed bottom-0 left-0 w-full z-[5000] glass-heavy pb-safe pt-2 px-6 flex justify-between items-center h-[80px] rounded-t-3xl shadow-[0_-5px_20px_rgba(0,0,0,0.3)]">
            <button @click="switchView('home')" class="nav-item flex flex-col items-center gap-1 transition-all duration-300 w-16" :class="{ 'active': currentView === 'home' }">
                <i class="fas fa-home text-xl text-gray-500 transition-colors duration-300"></i>
                <span class="text-[10px] text-gray-500 font-bold opacity-0 transition-opacity duration-300">Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</span>
            </button>
            
            <button @click="switchView('chat')" class="nav-item flex flex-col items-center gap-1 transition-all duration-300 w-16" :class="{ 'active': currentView === 'chat' }">
                <i class="fas fa-comments text-xl text-gray-500 transition-colors duration-300"></i>
                <span class="text-[10px] text-gray-500 font-bold opacity-0 transition-opacity duration-300">Ø´Ø§Øª</span>
            </button>

            <!-- Camera Button (New Feature) -->
             <button @click="triggerCamera" class="relative -top-8 w-16 h-16 rounded-full bg-gradient-to-tr from-indigo-600 to-purple-600 flex items-center justify-center shadow-[0_10px_20px_rgba(99,102,241,0.5)] border-4 border-[#0f172a] transform transition hover:scale-105 active:scale-95">
                <i class="fas fa-camera text-white text-2xl"></i>
            </button>

            <button @click="switchView('canvas')" class="nav-item flex flex-col items-center gap-1 transition-all duration-300 w-16" :class="{ 'active': currentView === 'canvas' }">
                <i class="fas fa-paint-brush text-xl text-gray-500 transition-colors duration-300"></i>
                <span class="text-[10px] text-gray-500 font-bold opacity-0 transition-opacity duration-300">Ø±Ø³Ù…</span>
            </button>

            <button @click="switchView('profile')" class="nav-item flex flex-col items-center gap-1 transition-all duration-300 w-16" :class="{ 'active': currentView === 'profile' }">
                <i class="fas fa-user text-xl text-gray-500 transition-colors duration-300"></i>
                <span class="text-[10px] text-gray-500 font-bold opacity-0 transition-opacity duration-300">Ø£Ù†Ø§</span>
            </button>
        </nav>

        <!-- --- MODALS --- -->

        <!-- Magic Wand Modal (AI Generation) -->
        <div v-if="showMagicModal" class="fixed inset-0 z-[5500] bg-black/80 backdrop-blur-md flex items-center justify-center p-4">
             <div class="glass w-full max-w-sm rounded-3xl p-6 shadow-2xl animate-slide-up border border-white/10 relative">
                 <button @click="showMagicModal = false" class="absolute top-4 left-4 text-gray-400 hover:text-white"><i class="fas fa-times text-xl"></i></button>
                 
                 <div class="text-center mb-6">
                     <div class="w-16 h-16 rounded-full bg-yellow-400/20 text-yellow-400 flex items-center justify-center mx-auto mb-4 text-3xl shadow-[0_0_20px_rgba(250,204,21,0.3)]">
                         <i class="fas fa-magic"></i>
                     </div>
                     <h3 class="font-bold text-xl text-white">Ø§Ù„Ø±Ø³Ø§Ù… Ø§Ù„Ø³Ø­Ø±ÙŠ</h3>
                     <p class="text-sm text-gray-400 mt-2">Ø§ÙƒØªØ¨ ÙˆØµÙØ§Ù‹ Ù„Ù„Ø±Ø³Ù…Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªÙ„ÙˆÙŠÙ†Ù‡Ø§</p>
                 </div>
                 
                 <textarea v-model="coloringPrompt" rows="3" placeholder="Ù…Ø«Ù„Ø§Ù‹: Ø£Ù…ÙŠØ±Ø© ÙÙŠ Ù‚Ù„Ø¹Ø©ØŒ Ø³ÙŠØ§Ø±Ø© Ø³Ø¨Ø§Ù‚ØŒ Ø¯ÙŠÙ†Ø§ØµÙˆØ± ØµØºÙŠØ±..." class="w-full bg-black/30 border border-white/10 rounded-xl p-4 text-white placeholder-gray-500 focus:border-indigo-500 focus:outline-none transition mb-4 resize-none"></textarea>
                 
                 <button @click="generateColoringPage(); showMagicModal = false" :disabled="isGenerating || !coloringPrompt.trim()" class="w-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-bold py-4 rounded-xl shadow-lg hover:shadow-indigo-500/30 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                     <span v-if="isGenerating"><i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯...</span>
                     <span v-else>Ø§Ø¨Ø¯Ø§ Ø§Ù„Ø³Ø­Ø±! <i class="fas fa-magic"></i></span>
                 </button>
             </div>
        </div>

        <!-- Color Picker Modal -->
        <div v-if="showColorPicker" class="fixed inset-0 z-[5300] bg-black/60 backdrop-blur-md flex items-center justify-center p-4" @click.self="showColorPicker = false">
            <div class="glass w-full max-w-sm rounded-3xl p-6 shadow-2xl animate-slide-up border border-white/10">
                <h3 class="font-bold text-lg mb-4 text-center">Ø§Ø®ØªØ± Ù„ÙˆÙ†Ø§Ù‹</h3>
                <div class="color-picker-sv mb-4 border border-white/20" :style="{ backgroundColor: `hsl(${picker.h}, 100%, 50%)` }" @mousedown="startPickerDrag" @mousemove="movePicker" @mouseup="endPicker" @touchstart.prevent="startPickerDrag" @touchmove.prevent="movePicker" @touchend="endPicker" ref="pickerArea">
                    <div class="sv-white"></div><div class="sv-black"></div><div class="picker-cursor" :style="{ left: picker.s + '%', top: (100 - picker.v) + '%' }"></div>
                </div>
                <div class="mb-6"><input type="range" v-model.number="picker.h" min="0" max="360" class="w-full h-3 rounded-full appearance-none cursor-pointer" style="background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);"></div>
                <div class="flex items-center justify-between gap-4">
                    <div class="w-12 h-12 rounded-full border-2 border-white/20 shadow-inner" :style="{ backgroundColor: tempColor }"></div>
                    <button @click="selectPickerColor" class="flex-1 bg-indigo-600 text-white py-3 rounded-xl font-bold hover:bg-indigo-700 transition shadow-lg shadow-indigo-600/30">ØªØ£ÙƒÙŠØ¯</button>
                </div>
            </div>
        </div>

        <!-- Friend Selection Modal -->
        <div v-if="showFriendModal" class="fixed inset-0 z-[5400] bg-black/70 backdrop-blur-md flex items-end sm:items-center justify-center">
            <div class="glass-heavy w-full sm:w-11/12 rounded-t-3xl sm:rounded-3xl p-6 shadow-2xl animate-slide-up max-h-[80vh] flex flex-col border border-white/10">
                <div class="flex justify-between items-center mb-6"><h3 class="font-bold text-lg">Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ù…Ø© Ø¥Ù„Ù‰...</h3><button @click="showFriendModal=false" class="text-gray-400 hover:text-white"><i class="fas fa-times text-xl"></i></button></div>
                <div class="grid grid-cols-1 gap-3 overflow-y-auto p-1 custom-scroll">
                    <div v-for="friend in onlineUsers" :key="friend.id" @click="onFriendSelected(friend)" class="flex items-center gap-3 p-4 rounded-2xl bg-white/5 border border-white/5 hover:border-indigo-500 cursor-pointer transition group">
                        <div class="w-12 h-12 rounded-full bg-indigo-500/20 text-indigo-300 flex items-center justify-center font-bold text-lg group-hover:bg-indigo-500 group-hover:text-white transition overflow-hidden">
                             <img v-if="friend.photoURL" :src="friend.photoURL" class="w-full h-full object-cover">
                             <span v-else>{{ friend.name.charAt(0) }}</span>
                        </div>
                        <div class="flex-1">
                            <p class="font-bold text-white">{{ friend.name }}</p>
                            <div class="flex items-center gap-2 text-xs text-gray-400"><span class="text-orange-400 font-bold">ğŸ”¥ {{ friend.streak }}</span><span>{{ friend.dailyRating?.emoji || 'ğŸ˜¶' }}</span></div>
                        </div>
                        <i class="fas fa-paper-plane text-gray-500 group-hover:text-indigo-400 transition"></i>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image Viewer -->
        <div v-if="viewingImage" class="fixed inset-0 z-[6000] bg-black/95 backdrop-blur-xl flex flex-col items-center justify-center animate-fade">
            <button @click="viewingImage = null" class="absolute top-5 right-5 text-white bg-white/10 w-10 h-10 rounded-full flex items-center justify-center z-50 hover:bg-white/20 transition"><i class="fas fa-times"></i></button>
            <div class="absolute top-5 left-5 text-white z-50"><p class="text-xs opacity-50">Ø§Ù„Ù…Ø±Ø³Ù„</p><h3 class="font-bold text-xl">{{ viewingName }}</h3></div>
            <img :src="viewingImage" class="max-w-full max-h-[80vh] object-contain shadow-2xl rounded-lg">
        </div>

        <!-- Rating Modal -->
        <transition name="fade">
            <div v-if="showRatingModal" class="fixed inset-0 z-[5500] bg-black/70 backdrop-blur-md flex items-center justify-center p-4">
                <div class="glass w-full max-w-sm rounded-3xl p-6 text-center border border-white/10">
                    <h3 class="font-bold text-xl mb-2 text-white">ÙƒÙŠÙ ÙƒØ§Ù† ÙŠÙˆÙ…ÙƒØŸ</h3>
                    <div class="flex justify-center gap-3 mb-6 text-3xl"><button v-for="star in 5" :key="star" @click="setDailyRating(star)" class="transition transform hover:scale-125 focus:outline-none" :class="star <= tempRating ? 'text-yellow-400 drop-shadow-[0_0_10px_rgba(250,204,21,0.5)]' : 'text-gray-600'">â˜…</button></div>
                    <div class="text-6xl mb-8 animate-bounce filter drop-shadow-lg">{{ getEmojiForStars(tempRating) }}</div>
                    <div class="flex gap-3"><button @click="showRatingModal = false" class="flex-1 bg-white/5 text-gray-300 py-3 rounded-xl hover:bg-white/10 transition">Ø¥Ù„ØºØ§Ø¡</button><button @click="saveRating" class="flex-1 bg-indigo-600 text-white py-3 rounded-xl font-bold shadow-lg hover:bg-indigo-500 transition">Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…</button></div>
                </div>
            </div>
        </transition>

        <!-- Send Type Modal -->
        <div v-if="showSendTypeModal" class="fixed inset-0 z-[5500] bg-black/70 backdrop-blur-md flex items-center justify-center p-4">
            <div class="glass w-full max-w-sm rounded-3xl p-6 shadow-2xl border border-white/10">
                <h3 class="font-bold text-lg text-center mb-6">ÙƒÙŠÙ ØªØ±ÙŠØ¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ØŸ</h3>
                <button @click="confirmSend('memory')" class="w-full mb-3 bg-gradient-to-r from-orange-500 to-pink-600 text-white p-4 rounded-2xl flex items-center gap-4 shadow-lg hover:scale-105 transition border border-white/10"><div class="bg-white/20 w-12 h-12 rounded-full flex items-center justify-center text-xl"><i class="fas fa-fire"></i></div><div class="text-right"><h4 class="font-bold">Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø°ÙƒØ±ÙŠØ§Øª</h4><p class="text-xs opacity-90">ÙŠØ¸Ù‡Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹ + ÙŠØ²ÙŠØ¯ Ø§Ù„Ø³ØªØ±ÙŠÙƒ ğŸ”¥</p></div></button>
                <button @click="confirmSend('chat')" class="w-full mb-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white p-4 rounded-2xl flex items-center gap-4 shadow-lg hover:scale-105 transition border border-white/10"><div class="bg-white/20 w-12 h-12 rounded-full flex items-center justify-center text-xl"><i class="fas fa-comment-dots"></i></div><div class="text-right"><h4 class="font-bold">Ø±Ø³Ø§Ù„Ø© Ø®Ø§ØµØ© (Ø´Ø§Øª)</h4><p class="text-xs opacity-90">Ù…Ø­Ø§Ø¯Ø«Ø© ØµÙˆØ± ÙÙ‚Ø· + Ù„Ø§ ÙŠØ¤Ø«Ø± Ø¨Ø§Ù„Ø³ØªØ±ÙŠÙƒ</p></div></button>
                <button @click="showSendTypeModal = false" class="w-full py-3 text-gray-400 font-bold hover:text-white transition">Ø¥Ù„ØºØ§Ø¡</button>
            </div>
        </div>

        <!-- Settings Modal (Refactored) -->
        <div v-if="showSettingsModal" class="fixed inset-0 z-[5500] bg-black/70 backdrop-blur-md flex items-center justify-center p-4">
            <div class="glass w-full max-w-sm rounded-3xl overflow-hidden border border-white/10 max-h-[85vh] overflow-y-auto">
                <div class="bg-indigo-600/50 p-4 flex justify-between items-center text-white"><h3 class="font-bold text-lg">Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</h3><button @click="closeSettings"><i class="fas fa-times"></i></button></div>
                <div class="p-6 space-y-4">
                    <!-- Install App -->
                    <div class="bg-white/5 p-4 rounded-xl border border-white/5"><div v-if="installPrompt"><button @click="installApp" class="w-full bg-blue-600 text-white py-2 rounded-lg font-bold">ØªØ«Ø¨ÙŠØª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚</button></div><div v-else><p class="text-xs text-gray-400 text-center">Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø«Ø¨Øª Ø£Ùˆ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…</p></div></div>
                    
                    <!-- App Lock -->
                    <div>
                        <h4 class="font-bold text-white mb-2 text-center">Ù‚ÙÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚</h4>
                        <div class="bg-black/30 rounded-xl relative mx-auto border border-white/10" style="width: 250px; height: 250px;">
                            <div class="pattern-lock-wrapper" style="width: 100%; height: 100%; margin:0;" @touchstart="startPattern" @touchmove="movePattern" @touchend="endSettingPattern" @mousedown="startPattern" @mousemove="movePattern" @mouseup="endSettingPattern"><canvas ref="settingCanvas" width="250" height="250" class="pattern-canvas"></canvas><div class="dots-container"><div v-for="n in 9" :key="n" class="dot-cell"><div class="dot" :class="{'active': currentPattern.includes(n-1)}"></div></div></div></div>
                        </div>
                        <p class="text-center text-xs text-indigo-400 mt-2 font-bold">{{ settingMessage }}</p>
                    </div>
                    <button v-if="tempPattern.length > 0" @click="savePattern" class="w-full bg-green-600 text-white py-2 rounded-lg font-bold shadow-lg">Ø­ÙØ¸ Ø§Ù„Ù†Ù‚Ø´</button>
                    <button v-if="userData.lockPattern && userData.lockPattern.length > 0" @click="removeLock" class="w-full bg-red-500/20 text-red-400 py-2 rounded-lg font-bold border border-red-500/30 hover:bg-red-500/30">Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù‚ÙÙ„</button>

                    <!-- Developer Options (Hidden) -->
                     <div v-if="isAdmin" class="pt-4 border-t border-white/10">
                        <h4 class="font-bold text-yellow-400 mb-2"><i class="fas fa-user-secret mr-2"></i>Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…Ø·ÙˆØ±</h4>
                        <button @click="openAdminPanel" class="w-full bg-yellow-500/20 text-yellow-400 py-2 rounded-lg font-bold border border-yellow-500/30 hover:bg-yellow-500/30">ÙØªØ­ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…</button>
                    </div>

                    <!-- Logout -->
                     <div class="pt-4 border-t border-white/10">
                        <button @click="logout" class="w-full bg-red-600 text-white py-3 rounded-xl font-bold hover:bg-red-700 transition flex items-center justify-center gap-2">
                            <i class="fas fa-sign-out-alt"></i> ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬
                        </button>
                     </div>
                </div>
            </div>
        </div>
        
        <!-- Pairing Modal -->
        <div v-if="showPairingModal" class="fixed inset-0 z-[5300] bg-black/70 backdrop-blur-md flex items-center justify-center p-4">
            <div class="glass w-full max-w-sm rounded-3xl p-6">
                <div class="flex justify-between items-center mb-4"><h3 class="font-bold text-lg">Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø´ØªØ±Ùƒ</h3><button @click="showPairingModal=false" class="text-gray-400"><i class="fas fa-times"></i></button></div>
                <div v-if="pairing.isPaired" class="text-center py-8">
                     <div class="w-16 h-16 rounded-full bg-green-500/20 text-green-400 flex items-center justify-center text-3xl mx-auto mb-4 animate-pulse border border-green-500/30"><i class="fas fa-link"></i></div>
                     <p class="text-green-400 font-bold mb-6">Ù…ØªØµÙ„ Ù…Ø¹ {{ pairing.partnerName }}</p>
                     <button @click="disconnectPairing(false)" class="bg-red-500 text-white px-6 py-3 rounded-xl shadow-lg font-bold">Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†</button>
                </div>
                <div v-else class="space-y-3">
                    <p class="text-xs text-gray-400 mb-2">Ø§Ø®ØªØ± ØµØ¯ÙŠÙ‚ Ù„Ù„Ø±Ø³Ù… Ù…Ø¹Ù‡ Ø§Ù„Ø¢Ù†:</p>
                    <div v-for="friend in onlineUsers" :key="friend.id" @click="openSessionSetup(friend)" class="glass p-3 rounded-xl flex items-center gap-3 cursor-pointer hover:bg-white/10 transition">
                         <div class="w-10 h-10 rounded-full bg-indigo-500/20 flex items-center justify-center font-bold text-indigo-300 overflow-hidden">
                             <img v-if="friend.photoURL" :src="friend.photoURL" class="w-full h-full object-cover">
                             <span v-else>{{ friend.name.charAt(0) }}</span>
                        </div>
                         <span class="font-bold flex-1">{{ friend.name }}</span>
                         <i class="fas fa-plug text-gray-500"></i>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Session Request Modal -->
        <div v-if="showSessionSetupModal" class="fixed inset-0 z-[5600] bg-black/80 backdrop-blur-md flex items-center justify-center p-4">
             <div class="glass w-full max-w-sm rounded-3xl p-6 animate-slide-up border border-white/10">
                <h3 class="font-bold text-lg mb-4">Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø© Ù…Ø¹ {{ setupParams.targetFriend?.name }}</h3>
                <div class="space-y-4">
                    <div class="bg-white/5 p-4 rounded-xl border border-white/5 flex items-center justify-between">
                         <span class="font-bold text-sm">Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ø³Ù…ØªÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠØ©</span>
                         <input type="checkbox" v-model="setupParams.shareCanvas" class="w-5 h-5 accent-indigo-600 rounded">
                    </div>
                    <button @click="startSessionRequest" class="w-full bg-green-600 text-white font-bold py-3 rounded-xl shadow-lg mt-2">Ø¥Ø±Ø³Ø§Ù„ Ø¯Ø¹ÙˆØ©</button>
                    <button @click="showSessionSetupModal = false" class="w-full text-gray-400 text-sm">Ø¥Ù„ØºØ§Ø¡</button>
                </div>
             </div>
        </div>

        <!-- Incoming Request -->
        <div v-if="incomingRequest" class="fixed inset-0 z-[5700] bg-black/90 backdrop-blur-md flex items-center justify-center p-4">
             <div class="glass w-full max-w-sm rounded-3xl p-6 text-center border border-indigo-500/50 shadow-[0_0_50px_rgba(99,102,241,0.2)]">
                 <div class="w-16 h-16 bg-indigo-500/20 rounded-full flex items-center justify-center mx-auto mb-4 text-2xl text-indigo-400 animate-bounce"><i class="fas fa-bell"></i></div>
                 <h3 class="font-bold text-xl mb-2">{{ incomingRequest.senderName }}</h3>
                 <p class="text-gray-300 mb-6">ÙŠØ±ÙŠØ¯ Ø§Ù„Ø±Ø³Ù… Ù…Ø¹Ùƒ Ø§Ù„Ø¢Ù†!</p>
                 <div class="flex gap-3">
                     <button @click="rejectPairing" class="flex-1 bg-white/10 text-white py-3 rounded-xl font-bold">Ø±ÙØ¶</button>
                     <button @click="acceptPairing" class="flex-1 bg-indigo-600 text-white py-3 rounded-xl font-bold shadow-lg shadow-indigo-600/40">Ù‚Ø¨ÙˆÙ„</button>
                 </div>
             </div>
        </div>

    </template> <!-- End user check -->

</div> <!-- End #app -->

<script>
    const { createApp } = Vue;
    const LOGICAL_WIDTH = 1080;
    const LOGICAL_HEIGHT = 1920;

    createApp({
        data() {
            return {
                isLoading: true, isLoggingIn: false, user: null, userData: {}, onlineUsers: [], loginName: '', errorMsg: '',
                mode: 'draw', 
                currentView: 'home', // Default view is now Home
                showFriendModal: false, showInbox: false, showAdminModal: false, showSettingsModal: false, showMagicModal: false,
                showAdminSetLockModal: false, adminTargetUser: null, showInfoModal: false, selectedUser: null,
                viewingImage: null, viewingName: '', 
                allMessages: [], memoryFeed: [], sending: false,
                isDrawing: false, ctx: null, 
                brushColor: '#ffffff', customColor: '#ffffff', brushSize: 5, isEraser: false, 
                uploadedImage: null,
                isAppLocked: false, currentPattern: [], tempPattern: [], settingMessage: 'Ø§Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø´', lockError: '',
                installPrompt: null, toast: { show: false, message: '', icon: '' }, confirmModal: { show: false, title: '', message: '', icon: '', action: null },
                showRatingModal: false, tempRating: 3,
                showTools: true,
                showPairingModal: false, incomingRequest: null, pairing: { isPaired: false, partnerId: null, partnerName: null, sessionId: null }, currentPath: [], remoteProcessedLines: 0,
                shareCurrentDrawing: false, isWaitingForAccept: false, inviteRequestId: null, inviteListenerUnsub: null,
                normalModeLines: [], coloringModeLines: [], 
                redoStack: [], 
                localActionIds: [], 
                activeColoringImageObj: null, coloringBaseImage: null, coloringCanvas: null, coloringCtx: null,
                selectedChatFriend: null, showSendTypeModal: false, pendingSendFriend: null,
                isFullscreen: false, zoomLevel: 1, panX: 0, panY: 0,
                gestureStartDist: 0, gestureStartZoom: 1, gestureStartPan: { x: 0, y: 0 },
                renderScale: 1, coloringPrompt: '', isGenerating: false, isGeneratingAI: false, isBucket: false,
                
                showSessionSetupModal: false,
                setupParams: { targetFriend: null, enableTimer: false, minutes: 2, seconds: 0, enableSync: true, shareCanvas: true },
                sessionTimer: { active: false, timeLeft: 0, intervalId: null },
                isCollaborationEnabled: true,
                
                showBrushPopup: false,
                showColorPicker: false,
                tempColor: '#ffffff',
                picker: { h: 0, s: 0, v: 100, isDragging: false },
                
                isToolsCollapsed: false
            }
        },
        watch: {
            'picker.h': function() { this.updateTempColor(); },
            'picker.s': function() { this.updateTempColor(); },
            'picker.v': function() { this.updateTempColor(); }
        },
        computed: { 
            unreadCount() { return this.allMessages.filter(m => m.receiverId === this.user?.uid && !m.read && m.category !== 'chat').length; },
            isAdmin() { return this.userData && this.userData.name === 'Saud'; },
            chatList() { return this.onlineUsers; },
            currentChatMessages() {
                if (!this.selectedChatFriend) return [];
                const fid = this.selectedChatFriend.id;
                const uid = this.user.uid;
                return this.allMessages.filter(m => ((m.senderId === uid && m.receiverId === fid) || (m.senderId === fid && m.receiverId === uid)) && m.category === 'chat').sort((a,b) => a.timestamp - b.timestamp);
            },
            historyGroups() {
                // Keep for legacy view if needed, but primary is memoryFeed now
                const groups = {};
                const sorted = this.allMessages.filter(m => m.category !== 'chat').sort((a, b) => b.timestamp - a.timestamp);
                sorted.forEach(msg => {
                    const date = new Date(msg.timestamp).toDateString();
                    const isMe = msg.senderId === this.user.uid;
                    const friendId = isMe ? msg.receiverId : msg.senderId;
                    const friendData = this.onlineUsers.find(u => u.id === friendId) || { name: msg.senderName, streak: 0, dailyRating: { emoji: 'ğŸ˜¶' } };
                    if (!groups[date]) groups[date] = {};
                    if (!groups[date][friendId]) { groups[date][friendId] = { friendName: friendData.name, friendStreak: friendData.streak, friendEmoji: friendData.dailyRating?.emoji || 'ğŸ˜¶', me: null, them: null }; }
                    if (isMe && !groups[date][friendId].me) groups[date][friendId].me = msg;
                    else if (!isMe && !groups[date][friendId].them) groups[date][friendId].them = msg;
                });
                return groups;
            }
        },
        mounted() {
            const savedLines = localStorage.getItem('universal_draw_normal_lines');
            if (savedLines) { try { this.normalModeLines = JSON.parse(savedLines); } catch(e) {} }
            
            const check = setInterval(() => { if (window.firebaseData) { clearInterval(check); this.initFirebase(); } }, 100);
            window.addEventListener('resize', this.handleResize);
            window.addEventListener('orientationchange', () => setTimeout(this.handleResize, 200));
            window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); this.installPrompt = e; });
        },
        methods: {
            handleResize() {
                // Ensure context exists regardless of current view, if canvas is in DOM
                const canvas = this.$refs.canvas;
                if (!canvas) return;
                
                this.ctx = canvas.getContext('2d', { willReadFrequently: true });
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                if (!this.coloringCanvas) {
                    this.coloringCanvas = document.createElement('canvas');
                }
                
                if (this.coloringCanvas.width !== LOGICAL_WIDTH || this.coloringCanvas.height !== LOGICAL_HEIGHT) {
                    this.coloringCanvas.width = LOGICAL_WIDTH;
                    this.coloringCanvas.height = LOGICAL_HEIGHT;
                    this.coloringCtx = this.coloringCanvas.getContext('2d', { willReadFrequently: true });
                    this.refreshColoringCache();
                }
                this.redraw();
            },
            refreshColoringCache() {
                if (!this.coloringCtx) return;
                this.coloringCtx.clearRect(0,0, this.coloringCanvas.width, this.coloringCanvas.height);
                this.coloringCtx.save();
                this.coloringModeLines.forEach(action => this.applyActionToCache(action));
                this.coloringCtx.restore();
            },
            
            // Updated switchView with persistence fix
            switchView(view) { 
                this.currentView = view; 
                if (view === 'canvas') {
                    // Force refresh of canvas when switching to it to prevent disappearance
                    this.$nextTick(() => { 
                        // Reload lines from storage if array is empty (failsafe)
                        if (this.mode === 'draw' && this.normalModeLines.length === 0) {
                            const saved = localStorage.getItem('universal_draw_normal_lines');
                            if(saved) this.normalModeLines = JSON.parse(saved);
                        }
                        this.handleResize(); 
                        this.redraw();
                    }); 
                } else if (view === 'chat') {
                    this.$nextTick(() => {
                         const container = this.$refs.chatContainer; 
                         if(container) container.scrollTop = container.scrollHeight;
                    });
                }
            },
            
            isUserOnline(u) {
                // Check if lastSeen is within 5 minutes (300000 ms)
                if (!u.lastSeen) return false;
                return (Date.now() - u.lastSeen) < 300000;
            },
            
            selectChatFriend(friend) { this.selectedChatFriend = friend; this.$nextTick(() => { const container = this.$refs.chatContainer; if(container) container.scrollTop = container.scrollHeight; }); },
            onFriendSelected(friend) { this.pendingSendFriend = friend; this.showFriendModal = false; this.showSendTypeModal = true; },
            confirmSend(category) { this.showSendTypeModal = false; if (this.pendingSendFriend) { this.executeSend(this.pendingSendFriend, category); } },
            initFirebase() {
                const { auth, onAuthStateChanged, db, doc, onSnapshot, collection, query, where, updateDoc, orderBy } = window.firebaseData;
                onAuthStateChanged(auth, (user) => {
                    this.user = user; this.isLoading = false;
                    if (user) {
                        const device = this.getDeviceInfo();
                        updateDoc(doc(db, "users", user.uid), { device: device, lastSeen: Date.now() }).catch(e=>{});
                        onSnapshot(doc(db, "users", user.uid), (docSnap) => { if (docSnap.exists()) { this.userData = docSnap.data(); if (this.userData.lockPattern && this.userData.lockPattern.length > 0) this.isAppLocked = true; } });
                        this.allMessages = [];
                        
                        // Messages for Chat
                        const q1 = query(collection(db, "messages"), where("receiverId", "==", user.uid));
                        onSnapshot(q1, (snap) => { snap.docChanges().forEach(change => { if (change.type === "added") this.allMessages.push({ id: change.doc.id, ...change.doc.data() }); if (change.type === "modified") { const idx = this.allMessages.findIndex(m => m.id === change.doc.id); if(idx!==-1) this.allMessages[idx] = { id: change.doc.id, ...change.doc.data() }; } }); });
                        const q2 = query(collection(db, "messages"), where("senderId", "==", user.uid));
                        onSnapshot(q2, (snap) => { snap.docChanges().forEach(change => { if (change.type === "added" && !this.allMessages.find(m => m.id === change.doc.id)) { this.allMessages.push({ id: change.doc.id, ...change.doc.data() }); } }); });
                        
                        // Social Feed (Memories) - Sort client-side to avoid index requirement
                        const feedQuery = query(collection(db, "messages"), where("category", "==", "memory"));
                        onSnapshot(feedQuery, (snap) => {
                            const rawPosts = snap.docs.map(doc => {
                                const data = doc.data();
                                const sender = this.onlineUsers.find(u => u.id === data.senderId) || { photoURL: null };
                                return {
                                    id: doc.id,
                                    ...data,
                                    userPhoto: sender.photoURL,
                                    isLiked: data.likes && data.likes.includes(user.uid),
                                    newComment: ''
                                };
                            });
                            // Sort Newest First
                            this.memoryFeed = rawPosts.sort((a, b) => b.timestamp - a.timestamp);
                        });

                        this.fetchOtherUsers();
                        this.listenForPairingRequests(); 
                        setTimeout(() => this.initCanvas(), 500);
                    }
                });
            },
            openPairingModal() { this.fetchOtherUsers(); this.showPairingModal = true; },
            
            openSessionSetup(friend) {
                this.setupParams = { 
                    targetFriend: friend, 
                    enableTimer: false, 
                    minutes: 2, 
                    seconds: 0, 
                    enableSync: true, 
                    shareCanvas: true 
                };
                this.showPairingModal = false;
                this.showSessionSetupModal = true;
            },

            startSessionRequest() {
                if (!this.setupParams.targetFriend) return;
                const totalSeconds = this.setupParams.enableTimer ? (this.setupParams.minutes * 60 + this.setupParams.seconds) : 0;
                
                this.sendPairingRequest(this.setupParams.targetFriend, {
                    sessionDuration: totalSeconds,
                    enableSync: this.setupParams.enableSync,
                    shareCanvas: this.setupParams.shareCanvas
                });
                this.showSessionSetupModal = false;
            },

            async sendPairingRequest(friend, options = {}) { 
                const { db, addDoc, collection, doc, onSnapshot, deleteDoc } = window.firebaseData; 
                try { 
                    const linesToSend = options.shareCanvas ? JSON.parse(JSON.stringify(this.normalModeLines)) : [];
                    
                    this.isCollaborationEnabled = options.enableSync;
                    
                    const payload = { 
                        senderId: this.user.uid, 
                        senderName: this.userData.name, 
                        receiverId: friend.id, 
                        status: 'pending', 
                        timestamp: Date.now(), 
                        shareDrawing: options.shareCanvas,
                        lines: linesToSend, 
                        activityType: this.mode, 
                        coloringImage: this.mode === 'color' ? this.coloringBaseImage : null,
                        sessionDuration: options.sessionDuration || 0,
                        enableSync: options.enableSync
                    };
                    
                    const docRef = await addDoc(collection(db, "pairing_requests"), payload); 
                    this.inviteRequestId = docRef.id;
                    if (this.inviteListenerUnsub) this.inviteListenerUnsub(); 
                    this.inviteListenerUnsub = onSnapshot(doc(db, "pairing_requests", docRef.id), (snap) => {
                        if (!snap.exists()) { 
                            if (this.isWaitingForAccept) { 
                                this.isWaitingForAccept = false; 
                                this.showToast("ØªÙ… Ø±ÙØ¶ Ø£Ùˆ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¯Ø¹ÙˆØ©"); 
                                if(this.inviteListenerUnsub) { this.inviteListenerUnsub(); this.inviteListenerUnsub = null; } 
                            } return; 
                        }
                        const data = snap.data();
                        if (data.status === 'accepted' && data.sessionId) { 
                            this.isWaitingForAccept = false; 
                            this.startSession(data.sessionId, data.receiverId, friend.name);
                            if (options.sessionDuration > 0) this.startTimer(options.sessionDuration);
                            setTimeout(() => { deleteDoc(doc(db, "pairing_requests", docRef.id)).catch(e=>{}); }, 1000); 
                            if(this.inviteListenerUnsub) { this.inviteListenerUnsub(); this.inviteListenerUnsub = null; } 
                            
                            // Auto switch to canvas on accept
                            this.switchView('canvas');
                        }
                    });
                    this.isWaitingForAccept = true;
                    this.showToast("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¯Ø¹ÙˆØ© Ø§Ù„Ø±Ø³Ù…"); 
                } catch(e) { console.error(e); this.showToast("ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„"); } 
            },
            cancelWaiting() { if (this.inviteRequestId) { const { db, deleteDoc, doc } = window.firebaseData; deleteDoc(doc(db, "pairing_requests", this.inviteRequestId)).catch(e => console.error(e)); } if (this.inviteListenerUnsub) { this.inviteListenerUnsub(); this.inviteListenerUnsub = null; } this.isWaitingForAccept = false; this.inviteRequestId = null; },
            listenForPairingRequests() { const { db, collection, query, where, onSnapshot } = window.firebaseData; const q = query(collection(db, "pairing_requests"), where("receiverId", "==", this.user.uid), where("status", "==", "pending")); onSnapshot(q, (snap) => { snap.docChanges().forEach(change => { if (change.type === "added") { this.incomingRequest = { id: change.doc.id, ...change.doc.data() }; } if (change.type === "removed" && this.incomingRequest && this.incomingRequest.id === change.doc.id) { this.incomingRequest = null; } }); }); },
            
            async acceptPairing() { 
                if(!this.incomingRequest) return; 
                const reqId = this.incomingRequest.id;
                const senderId = this.incomingRequest.senderId;
                const senderName = this.incomingRequest.senderName;
                const shareCanvas = this.incomingRequest.shareDrawing === true;
                const incomingType = this.incomingRequest.activityType;
                const incomingImage = this.incomingRequest.coloringImage;
                const duration = this.incomingRequest.sessionDuration || 0;
                
                this.isCollaborationEnabled = this.incomingRequest.enableSync !== false; 

                const rawLines = (this.incomingRequest.lines && Array.isArray(this.incomingRequest.lines)) ? this.incomingRequest.lines : [];
                const initialLines = shareCanvas ? JSON.parse(JSON.stringify(rawLines)) : [];
                
                const { db, addDoc, collection, updateDoc, doc } = window.firebaseData; 
                try {
                    if (incomingType === 'color' && incomingImage) {
                        this.mode = 'color';
                        this.showToast("Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù„ÙˆØ­Ø© Ø§Ù„ØªÙ„ÙˆÙŠÙ†...", "fas fa-spinner fa-spin");
                        await this.loadColoringImage(incomingImage);
                        this.coloringModeLines = []; this.redoStack = []; this.localActionIds = [];
                        if (this.coloringCtx) this.coloringCtx.clearRect(0,0,this.coloringCanvas.width, this.coloringCanvas.height);
                    } else {
                        this.mode = 'draw';
                        if (!shareCanvas) {
                            this.normalModeLines = []; 
                            this.redoStack = []; 
                            this.localActionIds = [];
                            localStorage.removeItem('universal_draw_normal_lines'); 
                        } else if (this.incomingRequest.shareDrawing) {
                             this.normalModeLines = [];
                             this.redoStack = [];
                             this.localActionIds = [];
                        }
                    }
                    
                    this.switchView('canvas'); // Auto switch to canvas

                    await this.$nextTick(); 
                    this.initCanvas();
                    
                    if (this.mode === 'draw' && initialLines.length > 0) { 
                        this.normalModeLines = initialLines; 
                        localStorage.setItem('universal_draw_normal_lines', JSON.stringify(this.normalModeLines)); 
                        this.redraw(); 
                    } else if (this.mode === 'color' && initialLines.length > 0) {
                        this.coloringModeLines = initialLines;
                        this.refreshColoringCache();
                        this.redraw();
                    }
                    
                    const sessionData = { users: [this.user.uid, senderId], lines: initialLines };
                    if (incomingImage) sessionData.coloringImage = incomingImage;

                    const sessionRef = await addDoc(collection(db, "sessions"), sessionData); 
                    await updateDoc(doc(db, "pairing_requests", reqId), { status: 'accepted', sessionId: sessionRef.id }); 
                    
                    this.startSession(sessionRef.id, senderId, senderName);
                    if (duration > 0) this.startTimer(duration);

                } catch (e) { console.error("Error accepting pairing:", e); this.showToast("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„"); } finally { this.incomingRequest = null; }
            },

            rejectPairing() { const { db, deleteDoc, doc } = window.firebaseData; deleteDoc(doc(db, "pairing_requests", this.incomingRequest.id)); this.incomingRequest = null; },
            startSession(sessionId, partnerId, partnerName) { this.pairing = { isPaired: true, partnerId, partnerName, sessionId }; this.remoteProcessedLines = 0; this.showToast(`ØªÙ… Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† Ù…Ø¹ ${partnerName}`, "fas fa-link"); this.$nextTick(() => { setTimeout(() => { this.initCanvas(); this.listenToSession(); }, 100); }); },
            
            startTimer(seconds) {
                if (this.sessionTimer.intervalId) clearInterval(this.sessionTimer.intervalId);
                this.sessionTimer = { active: true, timeLeft: seconds, intervalId: null };
                
                this.sessionTimer.intervalId = setInterval(() => {
                    if (this.sessionTimer.timeLeft > 0) {
                        this.sessionTimer.timeLeft--;
                    } else {
                        clearInterval(this.sessionTimer.intervalId);
                        this.sessionTimer.active = false;
                        this.showConfirm("Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!", "Ù„Ù‚Ø¯ Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ø¬Ù„Ø³Ø©.", "fas fa-hourglass-end", () => {});
                    }
                }, 1000);
            },
            
            formatTime(seconds) {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            },

            listenToSession() { 
                const { db, doc, onSnapshot } = window.firebaseData; 
                onSnapshot(doc(db, "sessions", this.pairing.sessionId), (docSnap) => { 
                    if (docSnap.exists()) { 
                        const data = docSnap.data(); 
                        
                        if (data.isGenerating !== undefined) {
                            this.isGeneratingAI = data.isGenerating;
                        }

                        const currentImage = data.coloringImage;
                        if (currentImage !== undefined) {
                            if (currentImage === null && this.coloringBaseImage !== null) {
                                this.coloringBaseImage = null;
                                this.activeColoringImageObj = null;
                                this.redraw();
                            } else if (currentImage !== null && currentImage !== this.coloringBaseImage) {
                                this.loadColoringImage(currentImage).then(() => this.redraw());
                            }
                        }

                        const lines = data.lines || []; 
                        
                        if (this.mode === 'color') { 
                            this.coloringModeLines = lines; 
                            this.refreshColoringCache(); 
                        } else { 
                            this.normalModeLines = lines; 
                            localStorage.setItem('universal_draw_normal_lines', JSON.stringify(this.normalModeLines)); 
                        }
                        this.remoteProcessedLines = lines.length;
                        this.redraw();

                    } else { this.disconnectPairing(true); } 
                }); 
            },

            redraw() {
                const c = this.$refs.canvas;
                if (!c || !this.ctx) return;
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);

                // Redraw white background for canvas
                this.ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
                this.ctx.fillStyle = "#ffffff"; 
                this.ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

                if (this.mode === 'color') {
                    if (this.coloringCanvas) { 
                        this.ctx.drawImage(this.coloringCanvas, 0, 0); 
                    }
                    
                    this.ctx.save();
                    if (this.isDrawing && !this.isBucket && this.currentPath.length > 0) {
                        this.ctx.beginPath(); 
                        this.ctx.lineWidth = this.isEraser ? 25 : this.brushSize; 
                        
                        if (this.isEraser) {
                            this.ctx.globalCompositeOperation = 'source-over';
                            this.ctx.strokeStyle = '#ffffff';
                        } else {
                            this.ctx.globalCompositeOperation = 'source-over';
                            this.ctx.strokeStyle = this.brushColor;
                        }

                        this.ctx.lineCap = 'round'; 
                        this.ctx.lineJoin = 'round';
                        this.ctx.moveTo(this.currentPath[0].x, this.currentPath[0].y); 
                        for(let i=1; i<this.currentPath.length; i++) this.ctx.lineTo(this.currentPath[i].x, this.currentPath[i].y);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();
                    
                    if (this.activeColoringImageObj) {
                        this.ctx.save(); 
                        this.ctx.globalCompositeOperation = 'multiply'; 
                        this.ctx.drawImage(this.activeColoringImageObj, 0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT); 
                        this.ctx.restore();
                    }
                    
                } else {
                    this.ctx.save();
                    this.normalModeLines.forEach(line => this.drawRemoteLine(line));
                    
                    if (this.isDrawing && this.currentPath.length > 0) {
                        this.ctx.beginPath(); 
                        this.ctx.lineWidth = this.isEraser ? 25 : this.brushSize; 
                        
                        if (this.isEraser) {
                            this.ctx.globalCompositeOperation = 'destination-out';
                            this.ctx.strokeStyle = '#000000'; 
                        } else {
                            this.ctx.globalCompositeOperation = 'source-over';
                            this.ctx.strokeStyle = (this.customColor !== '#ffffff' && this.colors.indexOf(this.brushColor) === -1 ? this.customColor : this.brushColor);
                        }

                        this.ctx.lineCap = 'round'; 
                        this.ctx.lineJoin = 'round';
                        this.ctx.moveTo(this.currentPath[0].x, this.currentPath[0].y); 
                        for(let i=1; i<this.currentPath.length; i++) this.ctx.lineTo(this.currentPath[i].x, this.currentPath[i].y);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();
                }
            },

            drawRemoteLine(line) { 
                this.ctx.beginPath(); 
                this.ctx.lineWidth = line.width || 5; 
                this.ctx.lineCap = 'round'; 
                this.ctx.lineJoin = 'round';
                
                if (line.isEraser) {
                    this.ctx.globalCompositeOperation = 'destination-out';
                    this.ctx.strokeStyle = '#000000';
                } else {
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.strokeStyle = line.color; 
                }

                if (line.points && line.points.length > 0) { this.ctx.moveTo(line.points[0].x, line.points[0].y); for (let i = 1; i < line.points.length; i++) { this.ctx.lineTo(line.points[i].x, line.points[i].y); } } 
                this.ctx.stroke(); 
            },
            disconnectPairing(remote = false) { 
                if (!remote && this.pairing.sessionId) { const { db, doc, deleteDoc } = window.firebaseData; deleteDoc(doc(db, "sessions", this.pairing.sessionId)).catch(e => console.error(e)); } 
                this.pairing = { isPaired: false, partnerId: null, partnerName: null, sessionId: null }; 
                
                if (this.sessionTimer.intervalId) clearInterval(this.sessionTimer.intervalId);
                this.sessionTimer = { active: false, timeLeft: 0, intervalId: null };
                
                if (remote) this.showToast("ØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ù† Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø¢Ø®Ø±"); else this.showToast("ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†"); 
            },
            toggleFullscreen() { this.isFullscreen = !this.isFullscreen; if (!this.isFullscreen) { this.resetView(); } this.$nextTick(() => { this.handleResize(); }); },
            resetView() { this.zoomLevel = 1; this.panX = 0; this.panY = 0; this.handleResize(); },
            
            getPointerPos(e) { 
                const c = this.$refs.canvas;
                if (!c) return { x: 0, y: 0 };
                
                const rect = c.getBoundingClientRect();
                
                const scaleX = LOGICAL_WIDTH / rect.width;
                const scaleY = LOGICAL_HEIGHT / rect.height;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const x = (clientX - rect.left) * scaleX;
                const y = (clientY - rect.top) * scaleY;

                return { x, y };
            },

            handleStart(e) {
                if(this.isWaitingForAccept) return;
                if (e.touches && e.touches.length > 1) {
                    if (this.isDrawing) { this.stopDrawing(); } this.isDrawing = false; 
                    if (e.touches.length === 2) {
                        const t1 = e.touches[0]; const t2 = e.touches[1];
                        this.gestureStartDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY); this.gestureStartZoom = this.zoomLevel;
                        this.gestureStartPan = { x: this.panX, y: this.panY, centerX: (t1.clientX + t2.clientX) / 2, centerY: (t1.clientY + t2.clientY) / 2 };
                    }
                    return;
                }
                if (this.mode === 'color' && this.isBucket) { e.preventDefault(); const pos = this.getPointerPos(e); this.performFloodFill(Math.floor(pos.x), Math.floor(pos.y), this.brushColor); return; }
                this.startDrawing(e);
            },
            handleMove(e) {
                if (e.touches && e.touches.length > 1) {
                    e.preventDefault(); if (this.isDrawing) { this.stopDrawing(); this.isDrawing = false; }
                    if (e.touches.length === 2) {
                        const t1 = e.touches[0]; const t2 = e.touches[1];
                        const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                        if (this.gestureStartDist > 0) { const scaleChange = dist / this.gestureStartDist; let newZoom = this.gestureStartZoom * scaleChange; if (newZoom < 0.5) newZoom = 0.5; if (newZoom > 5) newZoom = 5; this.zoomLevel = newZoom; }
                        const currentCenterX = (t1.clientX + t2.clientX) / 2; const currentCenterY = (t1.clientY + t2.clientY) / 2;
                        const dx = currentCenterX - this.gestureStartPan.centerX; const dy = currentCenterY - this.gestureStartPan.centerY;
                        this.panX = this.gestureStartPan.x + dx; this.panY = this.gestureStartPan.y + dy;
                    }
                    return;
                }
                if (this.mode === 'color' && this.isBucket) return;
                this.draw(e);
            },
            handleEnd(e) { if (this.isDrawing) { this.stopDrawing(); } },
            startDrawing(e) { if (e.touches && e.touches.length > 1) { this.isDrawing = false; return; } if(this.isWaitingForAccept) return; this.isDrawing = true; this.currentPath = []; this.draw(e); }, 
            draw(e) { if (e.touches && e.touches.length > 1) { if (this.isDrawing) this.stopDrawing(); this.isDrawing = false; return; } if(!this.isDrawing || this.isWaitingForAccept) return; e.preventDefault(); const pos = this.getPointerPos(e); this.currentPath.push({x: pos.x, y: pos.y}); this.redraw(); },
            
            async stopDrawing() { 
                if(this.isWaitingForAccept) return; this.isDrawing=false; 
                if (this.currentPath.length > 0) { 
                    const actionId = Date.now().toString() + Math.random().toString(36).substr(2, 5);
                    const newStroke = { 
                        id: actionId,
                        type: 'stroke', 
                        userId: this.user.uid, 
                        isEraser: this.isEraser,
                        color: this.isEraser ? '#ffffff' : this.brushColor, 
                        width: this.isEraser ? 25 : this.brushSize, 
                        points: this.currentPath 
                    };
                    const actionToSend = JSON.parse(JSON.stringify(newStroke));

                    this.redoStack = []; 
                    this.localActionIds.push(actionId);
                    if (this.localActionIds.length > 40) this.localActionIds.shift();

                    if (this.mode === 'color') { 
                        this.coloringModeLines.push(actionToSend); 
                        this.applyActionToCache(actionToSend); 
                    } else { 
                        this.normalModeLines.push(actionToSend); 
                        if (!this.pairing.isPaired) { 
                            localStorage.setItem('universal_draw_normal_lines', JSON.stringify(this.normalModeLines)); 
                        } 
                    }
                    
                    if (this.pairing.isPaired && this.isCollaborationEnabled) { 
                        const { db, doc, updateDoc, arrayUnion } = window.firebaseData; 
                        try { await updateDoc(doc(db, "sessions", this.pairing.sessionId), { lines: arrayUnion(actionToSend) }); } catch(e) { console.error("Sync error", e); } 
                    }
                    
                    this.currentPath = []; this.redraw();
                } 
            },
            
            applyActionToCache(action) {
                if (!this.coloringCtx) return;
                this.coloringCtx.save();
                if (action.type === 'stroke') {
                    this.coloringCtx.beginPath(); 
                    this.coloringCtx.lineWidth = action.width; 
                    this.coloringCtx.lineCap = 'round'; 
                    this.coloringCtx.lineJoin = 'round';
                    if (action.isEraser) {
                         this.coloringCtx.strokeStyle = '#ffffff';
                    } else {
                         this.coloringCtx.strokeStyle = action.color;
                    }
                    if (action.points && action.points.length > 0) { this.coloringCtx.moveTo(action.points[0].x, action.points[0].y); for(let i=1; i<action.points.length; i++) this.coloringCtx.lineTo(action.points[i].x, action.points[i].y); }
                    this.coloringCtx.stroke();
                } else if (action.type === 'fill') { this.performFloodFill(Math.floor(action.x), Math.floor(action.y), action.color, true); }
                this.coloringCtx.restore();
            },
            cancelGeneration() { this.isGeneratingAI = false; this.isGenerating = false; },
            
            async deleteGeneratedImage() {
                this.coloringBaseImage = null;
                this.activeColoringImageObj = null;
                this.redraw();
                
                if (this.pairing.isPaired) {
                    const { db, doc, updateDoc } = window.firebaseData;
                    await updateDoc(doc(db, "sessions", this.pairing.sessionId), { coloringImage: null });
                }
            },
            
            async generateColoringPage() {
                if(!this.coloringPrompt.trim()) return;
                
                this.isGenerating = true; 
                this.isGeneratingAI = true;

                if (this.pairing.isPaired) {
                    const { db, doc, updateDoc } = window.firebaseData;
                    try {
                        await updateDoc(doc(db, "sessions", this.pairing.sessionId), { isGenerating: true });
                    } catch(e) { console.error("Sync start error", e); }
                }

                try {
                    const userText = this.coloringPrompt;
                    const magicPrompt = "detailed coloring book page of " + userText + ", intricate professional line art, thick clean outlines, high detail, realistic style, aesthetic, white background, no shading, no grayscale, vector quality, watertight paths for bucket fill";

                    const width = 1080;
                    const height = 1920;
                    const seed = Math.floor(Math.random() * 1000000);
                    
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(magicPrompt)}?width=${width}&height=${height}&nologo=true&private=true&model=flux&seed=${seed}`;

                    await this.loadColoringImage(imageUrl);
                    
                    if (this.isGeneratingAI) { 
                        this.coloringModeLines = []; 
                        this.redoStack = []; 
                        this.localActionIds = [];
                        if(this.coloringCtx) this.coloringCtx.clearRect(0, 0, this.coloringCanvas.width, this.coloringCanvas.height); 
                        this.redraw(); 
                        
                        if (this.pairing.isPaired) {
                            const { db, doc, updateDoc } = window.firebaseData;
                            await updateDoc(doc(db, "sessions", this.pairing.sessionId), { 
                                coloringImage: imageUrl,
                                isGenerating: false 
                            });
                        }

                        this.showToast("ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø±Ø³Ù…Ø©!", "fas fa-magic"); 
                    }
                } catch (e) { 
                    console.error(e); 
                    if (this.isGeneratingAI) this.showToast("ÙØ´Ù„ Ø§Ù„ØªÙˆÙ„ÙŠØ¯: " + e.message);
                    
                    if (this.pairing.isPaired) {
                        const { db, doc, updateDoc } = window.firebaseData;
                        updateDoc(doc(db, "sessions", this.pairing.sessionId), { isGenerating: false }).catch(e=>{});
                    }
                } finally {
                    this.isGenerating = false; 
                    this.isGeneratingAI = false;
                }
            },
            loadColoringImage(url) { return new Promise((resolve) => { const img = new Image(); img.crossOrigin = "Anonymous"; img.onload = () => { this.coloringBaseImage = url; this.activeColoringImageObj = img; resolve(); }; img.src = url; }); },
            activateBucket() { this.isBucket = true; this.isEraser = false; },
            activatePen() { this.isBucket = false; this.isEraser = false; },
            activateEraser() { this.isEraser = true; this.isBucket = false; },
            setColor(c) { this.brushColor = c; this.customColor = c; this.isEraser = false; },
            setCustomColor(e) { this.brushColor = e.target.value; this.customColor = e.target.value; this.isEraser = false; },
            
            performFloodFill(virtX, virtY, hexColor, isReplay = false) {
                if (!this.coloringCtx || !this.activeColoringImageObj) return;
                
                const startX = Math.floor(virtX); 
                const startY = Math.floor(virtY);
                
                const w = this.coloringCanvas.width;
                const h = this.coloringCanvas.height;
                
                const tempCvs = document.createElement('canvas'); tempCvs.width = w; tempCvs.height = h; const tCtx = tempCvs.getContext('2d');
                tCtx.drawImage(this.coloringCanvas, 0, 0);
                tCtx.save(); tCtx.globalCompositeOperation = 'multiply'; tCtx.drawImage(this.activeColoringImageObj, 0, 0, w, h); tCtx.restore();
                const imageData = tCtx.getImageData(0, 0, w, h); const data = imageData.data;
                const startPos = (startY * w + startX) * 4; const startR = data[startPos], startG = data[startPos+1], startB = data[startPos+2];
                const r = parseInt(hexColor.slice(1, 3), 16); const g = parseInt(hexColor.slice(3, 5), 16); const b = parseInt(hexColor.slice(5, 7), 16);
                if (startR < 100 && startG < 100 && startB < 100) return; if (Math.abs(startR - r) < 10 && Math.abs(startG - g) < 10 && Math.abs(startB - b) < 10) return;
                const stack = [startX, startY]; const visited = new Uint8Array(w * h);
                const match = (idx) => { const dr = Math.abs(data[idx] - startR); const dg = Math.abs(data[idx+1] - startG); const db = Math.abs(data[idx+2] - startB); return (dr < 50 && dg < 50 && db < 50); };
                const colorLayerData = this.coloringCtx.getImageData(0, 0, w, h); const cData = colorLayerData.data;
                while (stack.length) {
                    let y = stack.pop(); let x = stack.pop(); let idx = y * w + x;
                    if (visited[idx]) continue;
                    let lx = x; while (lx >= 0 && match((y * w + lx) * 4)) { visited[y * w + lx] = 1; lx--; } lx++; 
                    let rx = x + 1; while (rx < w && match((y * w + rx) * 4)) { visited[y * w + rx] = 1; rx++; } rx--; 
                    for (let i = lx; i <= rx; i++) {
                        let pIdx = (y * w + i) * 4; cData[pIdx] = r; cData[pIdx+1] = g; cData[pIdx+2] = b; cData[pIdx+3] = 255;
                        if (y > 0) { let upIdx = ((y - 1) * w + i); if (!visited[upIdx] && match(upIdx * 4)) stack.push(i, y - 1); }
                        if (y < h - 1) { let downIdx = ((y + 1) * w + i); if (!visited[downIdx] && match(downIdx * 4)) stack.push(i, y + 1); }
                    }
                }
                this.coloringCtx.putImageData(colorLayerData, 0, 0);
                if (!isReplay) {
                    const actionId = Date.now().toString() + Math.random().toString(36).substr(2, 5);
                    const action = { id: actionId, type: 'fill', x: virtX, y: virtY, color: hexColor }; 
                    this.coloringModeLines.push(action);
                    
                    this.redoStack = [];
                    this.localActionIds.push(actionId);
                    if (this.localActionIds.length > 40) this.localActionIds.shift();

                    if (this.pairing.isPaired && this.isCollaborationEnabled) { 
                        const { db, doc, updateDoc, arrayUnion } = window.firebaseData; 
                        updateDoc(doc(db, "sessions", this.pairing.sessionId), { lines: arrayUnion(action) }).catch(e=>console.error(e)); 
                    }
                    this.redraw();
                }
            },
            
            async undo() {
                const lines = this.mode === 'color' ? this.coloringModeLines : this.normalModeLines;
                if (this.localActionIds.length === 0) return;

                const lastActionId = this.localActionIds.pop();
                const index = lines.findIndex(line => line.id === lastActionId);
                
                if (index !== -1) {
                    const item = lines.splice(index, 1)[0]; 
                    this.redoStack.push(item);
                    if (this.redoStack.length > 40) this.redoStack.shift();
                    
                    if (this.mode === 'color') {
                        this.refreshColoringCache();
                    } else {
                        if (!this.pairing.isPaired) localStorage.setItem('universal_draw_normal_lines', JSON.stringify(this.normalModeLines));
                    }
                    
                    this.redraw();
                    
                    if (this.pairing.isPaired) {
                         this.syncUndoRemove(item); 
                    }
                }
            },
            
            async redo() {
                if (this.redoStack.length > 0) { 
                    const item = this.redoStack.pop(); 
                    const lines = this.mode === 'color' ? this.coloringModeLines : this.normalModeLines;
                    
                    lines.push(item);
                    this.localActionIds.push(item.id);

                    if (this.mode === 'color') {
                         this.applyActionToCache(item); 
                    } else if (!this.pairing.isPaired) { 
                         localStorage.setItem('universal_draw_normal_lines', JSON.stringify(this.normalModeLines)); 
                    } 
                    
                    this.redraw(); 
                    if (this.pairing.isPaired) this.syncRedoAdd(item); 
                }
            },
            async syncUndoRemove(item) { const { db, doc, updateDoc } = window.firebaseData; const lines = this.mode === 'color' ? this.coloringModeLines : this.normalModeLines; await updateDoc(doc(db, "sessions", this.pairing.sessionId), { lines: lines }); },
            async syncRedoAdd(item) { const { db, doc, updateDoc, arrayUnion } = window.firebaseData; await updateDoc(doc(db, "sessions", this.pairing.sessionId), { lines: arrayUnion(item) }); },
            
            clearCanvas() {
                if (this.mode === 'color') {
                    this.redoStack = [];
                    this.localActionIds = [];
                    this.coloringModeLines = [];
                    if(this.coloringCtx) this.coloringCtx.clearRect(0, 0, this.coloringCanvas.width, this.coloringCanvas.height);
                } else {
                    this.redoStack = [];
                    this.localActionIds = [];
                    this.normalModeLines = [];
                    localStorage.removeItem('universal_draw_normal_lines');
                }

                this.redraw();

                if (this.pairing.isPaired) {
                    const { db, doc, updateDoc } = window.firebaseData;
                    this.remoteProcessedLines = 0; 
                    updateDoc(doc(db, "sessions", this.pairing.sessionId), { lines: [] }).catch(e => console.error(e));
                }
            },

            initCanvas() { this.handleResize(); },
            handleImageUpload(e) { const f = e.target.files[0]; if(f){ const r=new FileReader(); r.onload=(e)=>{this.uploadedImage=e.target.result;}; r.readAsDataURL(f); } },
            removeImage() { this.uploadedImage = null; },
            switchMode(m) { this.mode = m; if(m === 'draw' || m === 'color') { this.isBucket = false; this.$nextTick(() => { this.handleResize(); }); } },
            async resetAllDiaries() { this.showConfirm("ØªØµÙÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠØ§Øª", "Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ±.", "fas fa-trash-restore", async () => { this.isLoading = true; const { db, collection, getDocs, deleteDoc, doc } = window.firebaseData; try { const q = collection(db, "messages"); const snapshot = await getDocs(q); const deletePromises = snapshot.docs.map(document => deleteDoc(doc(db, "messages", document.id))); await Promise.all(deletePromises); this.allMessages = []; this.showToast("ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­"); } catch(e) { console.error(e); this.showToast("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù", "fas fa-times"); } finally { this.isLoading = false; } }); },
            setDailyRating(stars) { this.tempRating = stars; },
            getEmojiForStars(stars) { const map = { 1: 'â›ˆï¸', 2: 'â˜ï¸', 3: 'ğŸ™‚', 4: 'ğŸ˜„', 5: 'ğŸ¤©' }; return map[stars] || 'ğŸ˜¶'; },
            async saveRating() { const emoji = this.getEmojiForStars(this.tempRating); const { db, doc, updateDoc } = window.firebaseData; try { await updateDoc(doc(db, "users", this.user.uid), { dailyRating: { stars: this.tempRating, emoji: emoji, date: new Date().toDateString() } }); this.showToast(`ØªÙ…: ${emoji}`); this.showRatingModal = false; } catch(e) { this.showToast("Ø®Ø·Ø£"); } },
            async uploadToImgBB(blob) { const apiKey = "09a27d6572c192d8c9b066310d5e9186"; const formData = new FormData(); formData.append("image", blob); const response = await fetch(`https://api.imgbb.com/1/upload?key=${apiKey}`, { method: "POST", body: formData }); const data = await response.json(); if (data.success) { return data.data.url; } else { throw new Error("ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ ImgBB"); } },
            async executeSend(friend, category) {
                this.sending = true; const { db, collection, addDoc, doc, updateDoc } = window.firebaseData; let blob; 
                if (this.mode === 'draw' || this.mode === 'color') { const dataUrl = this.$refs.canvas.toDataURL('image/png'); blob = await (await fetch(dataUrl)).blob(); } 
                else { if (!this.uploadedImage) { this.showToast("ÙØ§Ø±Øº!"); this.sending = false; return; } blob = await (await fetch(this.uploadedImage)).blob(); } 
                try { 
                    const imageUrl = await this.uploadToImgBB(blob); 
                    await addDoc(collection(db, "messages"), { senderId: this.user.uid, senderName: this.userData.name, receiverId: friend.id, imageUrl: imageUrl, type: this.mode==='image'?'image':'drawing', category: category, timestamp: Date.now(), read: false }); 
                    if (category === 'memory') {
                        const userRef = doc(db, "users", this.user.uid); const today = new Date().toISOString().split('T')[0]; 
                        if (this.userData.lastPostDate !== today) { let ns = (this.userData.streak || 0) + 1; if (this.userData.lastPostDate) { const diff = (new Date() - new Date(this.userData.lastPostDate))/(1000*60*60*24); if(diff > 2) ns = 1; } await updateDoc(userRef, { streak: ns, lastPostDate: today }); } 
                    }
                    setTimeout(() => { this.sending = false; if (category === 'chat') { this.showToast("ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø­Ø§Ø¯Ø«Ø©", "fas fa-comments"); } else { this.showToast("ØªÙ… Ø§Ù„Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª", "fas fa-history"); } }, 1000); 
                } catch (e) { console.error(e); this.sending = false; this.showToast("ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„"); } 
            },
            
            // --- Social Feed Interactions ---
            async toggleLike(post) {
                const { db, doc, updateDoc, arrayUnion, arrayRemove } = window.firebaseData;
                const postRef = doc(db, "messages", post.id);
                try {
                    if (post.isLiked) {
                        await updateDoc(postRef, { likes: arrayRemove(this.user.uid) });
                        // Optimistic update
                        post.isLiked = false;
                        if (post.likes) post.likes = post.likes.filter(id => id !== this.user.uid);
                    } else {
                        await updateDoc(postRef, { likes: arrayUnion(this.user.uid) });
                        post.isLiked = true;
                        if (!post.likes) post.likes = [];
                        post.likes.push(this.user.uid);
                    }
                } catch(e) { console.error(e); }
            },
            
            async addComment(post) {
                if (!post.newComment || !post.newComment.trim()) return;
                const { db, doc, updateDoc, arrayUnion } = window.firebaseData;
                const comment = {
                    userId: this.user.uid,
                    userName: this.userData.name,
                    text: post.newComment.trim(),
                    timestamp: Date.now()
                };
                try {
                    await updateDoc(doc(db, "messages", post.id), { comments: arrayUnion(comment) });
                    post.newComment = '';
                    if (!post.comments) post.comments = [];
                    post.comments.push(comment);
                } catch(e) { console.error(e); }
            },
            
            // --- Profile Photo ---
            triggerProfileUpload() { this.$refs.profileInput.click(); },
            async handleProfileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                this.showToast("Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø©...", "fas fa-cloud-upload-alt");
                try {
                    const blob = await new Promise(resolve => {
                         const reader = new FileReader();
                         reader.onload = (e) => resolve(new Blob([e.target.result]));
                         reader.readAsArrayBuffer(file);
                    });
                    
                    const url = await this.uploadToImgBB(blob);
                    
                    const { db, doc, updateDoc } = window.firebaseData;
                    await updateDoc(doc(db, "users", this.user.uid), { photoURL: url });
                    this.userData.photoURL = url; // Local update
                    this.showToast("ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­");
                } catch(e) { console.error(e); this.showToast("ÙØ´Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«"); }
            },

            // --- Camera Trigger ---
            triggerCamera() {
                this.switchMode('image');
                this.switchView('canvas');
                // Wait for view switch then trigger input
                this.$nextTick(() => {
                    if (this.$refs.imageUploadInput) this.$refs.imageUploadInput.click();
                });
            },

            viewImage(url, name) { this.viewingImage = url; this.viewingName = name; },
            formatDateHeader(dateStr) { const date = new Date(dateStr); const today = new Date(); const yesterday = new Date(today); yesterday.setDate(yesterday.getDate() - 1); if (date.toDateString() === today.toDateString()) return "Ø§Ù„ÙŠÙˆÙ…"; if (date.toDateString() === yesterday.toDateString()) return "Ø£Ù…Ø³"; return date.toLocaleDateString('ar-EG', { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' }); },
            showToast(msg, icon = 'fas fa-check-circle') { this.toast = { show: true, message: msg, icon: icon }; setTimeout(() => { this.toast.show = false; }, 3000); },
            showConfirm(title, msg, icon, action) { this.confirmModal = { show: true, title, message: msg, icon, action: () => { action(); this.confirmModal.show = false; } }; },
            async installApp() { if (!this.installPrompt) return; this.installPrompt.prompt(); const { outcome } = await this.installPrompt.userChoice; if (outcome === 'accepted') this.installPrompt = null; },
            getDeviceInfo() { const ua = navigator.userAgent; const android = ua.match(/Android.*?; (.*?) Build/); if (android && android.length > 1) return android[1]; if (/iPhone/i.test(ua)) return 'iPhone'; if (/Windows/i.test(ua)) return 'Windows PC'; return 'Mobile'; },
            async handleQuickLogin() { if (!this.loginName.trim()) return; this.isLoggingIn = true; this.errorMsg = ''; const cleanName = this.loginName.trim(); const safeEmail = `${cleanName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()}@universal.local`; const pass = "universalPass123!"; const { auth, signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile, db, setDoc, doc } = window.firebaseData; try { await signInWithEmailAndPassword(auth, safeEmail, pass); } catch (error) { try { const cred = await createUserWithEmailAndPassword(auth, safeEmail, pass); await updateProfile(cred.user, { displayName: cleanName }); const device = this.getDeviceInfo(); await setDoc(doc(db, "users", cred.user.uid), { name: cleanName, email: safeEmail, streak: 0, lastPostDate: null, uid: cred.user.uid, lockPattern: [], device: device, lastSeen: Date.now() }, { merge: true }); } catch (e) { this.errorMsg = "Ø®Ø·Ø£: " + e.message; } } this.isLoggingIn = false; },
            async savePattern() { const { db, doc, updateDoc } = window.firebaseData; try { await updateDoc(doc(db, "users", this.user.uid), { lockPattern: this.tempPattern }); this.showToast("ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù‚ÙÙ„"); this.closeSettings(); this.showAdminModal=false; } catch(e) { this.showToast("Ø®Ø·Ø£"); } },
            removeLock() { this.showConfirm("Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚ÙÙ„", "Ø­Ø°Ù Ø§Ù„Ø±Ù…Ø²ØŸ", "fas fa-unlock", async () => { const { db, doc, updateDoc } = window.firebaseData; await updateDoc(doc(db, "users", this.user.uid), { lockPattern: [] }); this.showToast("ØªÙ… Ø§Ù„Ø­Ø°Ù"); this.closeSettings(); }); },
            async resetUserLock(u) { this.showConfirm("ØªØµÙÙŠØ± Ø§Ù„Ù‚ÙÙ„", `ØªØµÙÙŠØ± Ù‚ÙÙ„ ${u.name}?`, "fas fa-key", async () => { const { db, doc, updateDoc } = window.firebaseData; await updateDoc(doc(db, "users", u.id), { lockPattern: [] }); this.showToast("ØªÙ…"); }); },
            async deleteUser(u) { this.showConfirm("Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", `Ø­Ø°Ù ${u.name}?`, "fas fa-trash-alt", async () => { const { db, deleteDoc, doc } = window.firebaseData; await deleteDoc(doc(db, "users", u.id)); this.onlineUsers = this.onlineUsers.filter(x => x.id !== u.id); this.showToast("ØªÙ… Ø§Ù„Ø­Ø°Ù"); }); },
            getDotIndex(x, y, w, h) { const col = Math.floor(x / (w / 3)); const row = Math.floor(y / (h / 3)); return (col >= 0 && col < 3 && row >= 0 && row < 3) ? row * 3 + col : -1; },
            startPattern(e) { this.currentPattern = []; this.lockError = ''; this.drawPatternLine(e); },
            movePattern(e) { e.preventDefault(); this.drawPatternLine(e); },
            drawPatternLine(e) { const canvas = (this.showSettingsModal || (this.isAdmin && this.showAdminModal) || this.showAdminSetLockModal) ? this.$refs.settingCanvas : this.$refs.lockCanvas; if (!canvas) return; const rect = canvas.getBoundingClientRect(); const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left; const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top; const idx = this.getDotIndex(x, y, rect.width, rect.height); if (idx !== -1 && !this.currentPattern.includes(idx)) this.currentPattern.push(idx); const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; if (this.currentPattern.length > 0) { const getPt = (i) => ({ x: (i % 3) * (canvas.width/3) + (canvas.width/6), y: Math.floor(i / 3) * (canvas.height/3) + (canvas.height/6) }); const start = getPt(this.currentPattern[0]); ctx.moveTo(start.x, start.y); for (let i = 1; i < this.currentPattern.length; i++) { const p = getPt(this.currentPattern[i]); ctx.lineTo(p.x, p.y); } const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; ctx.lineTo(x * scaleX, y * scaleY); ctx.stroke(); } },
            endPattern() { const c = this.$refs.lockCanvas; if(c) c.getContext('2d').clearRect(0,0,c.width,c.height); if (this.userData.lockPattern) { if (JSON.stringify(this.currentPattern) === JSON.stringify(this.userData.lockPattern)) this.isAppLocked = false; else this.lockError = "Ø®Ø·Ø£"; } this.currentPattern = []; },
            endSettingPattern() { const c = this.$refs.settingCanvas; if(c) c.getContext('2d').clearRect(0,0,c.width,c.height); if (this.currentPattern.length < 3) { this.settingMessage = "Ù‚ØµÙŠØ±"; this.currentPattern = []; } else { this.tempPattern = [...this.currentPattern]; this.settingMessage = "Ø¬Ø§Ù‡Ø²"; } },
            async saveAdminPattern() { if (!this.adminTargetUser) return; const { db, doc, updateDoc } = window.firebaseData; try { await updateDoc(doc(db, "users", this.adminTargetUser.id), { lockPattern: this.tempPattern }); this.showToast("ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙÙ„"); this.showAdminSetLockModal = false; } catch(e) { this.showToast("Ø®Ø·Ø£"); } },
            logout() { window.firebaseData.signOut(window.firebaseData.auth); this.isAppLocked = false; },
            async fetchOtherUsers() { const { db, collection, getDocs } = window.firebaseData; const snap = await getDocs(collection(db, "users")); const unique = new Set(); this.onlineUsers = []; snap.forEach(doc => { const d = doc.data(); if (doc.id !== this.user.uid && !unique.has(d.name)) { unique.add(d.name); this.onlineUsers.push({ id: doc.id, ...d }); } }); },
            openAdminPanel() { this.fetchOtherUsers(); this.showAdminModal = true; this.showSidebar = false; this.tempPattern=[]; this.settingMessage='Ø§Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø´'; },
            openSettings() { this.showSidebar = false; this.showSettingsModal = true; this.tempPattern = []; this.currentPattern = []; this.settingMessage = 'Ø§Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø´'; setTimeout(() => this.$nextTick(), 100); },
            closeSettings() { this.showSettingsModal = false; this.currentPattern = []; },
            showUserDetails(u) { this.selectedUser = u; this.showInfoModal = true; },
            handleLockAction(targetUser) { if (targetUser.lockPattern && targetUser.lockPattern.length > 0) { this.resetUserLock(targetUser); } else { this.adminTargetUser = targetUser; this.tempPattern = []; this.currentPattern = []; this.settingMessage = 'Ø§Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø´'; this.showAdminSetLockModal = true; setTimeout(() => { this.$nextTick(); }, 100); } },
            openFriendSelector() { this.fetchOtherUsers(); this.showFriendModal = true; },

            // Custom Color Picker Methods
            openColorPicker() { this.showColorPicker = true; this.picker.isDragging = false; },
            toggleBrushPopup() { this.showBrushPopup = !this.showBrushPopup; },
            
            updateTempColor() {
                const { h, s, v } = this.picker;
                // Simple HSL approx or convert properly
                this.tempColor = this.hsvToHex(h, s, v);
            },
            
            hsvToHex(h, s, v) {
                s /= 100; v /= 100;
                let c = v * s;
                let x = c * (1 - Math.abs((h / 60) % 2 - 1));
                let m = v - c;
                let r=0, g=0, b=0;
                if (0 <= h && h < 60) { r = c; g = x; b = 0; }
                else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
                else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
                else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
                else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
                else if (300 <= h && h <= 360) { r = c; g = 0; b = x; }
                r = Math.round((r + m) * 255).toString(16).padStart(2, '0');
                g = Math.round((g + m) * 255).toString(16).padStart(2, '0');
                b = Math.round((b + m) * 255).toString(16).padStart(2, '0');
                return `#${r}${g}${b}`;
            },

            startPickerDrag(e) { this.picker.isDragging = true; this.handlePickerMove(e); },
            movePicker(e) { if(this.picker.isDragging) this.handlePickerMove(e); },
            endPicker() { this.picker.isDragging = false; },
            
            handlePickerMove(e) {
                const rect = this.$refs.pickerArea.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                let x = clientX - rect.left;
                let y = clientY - rect.top;
                
                // Clamp
                if (x < 0) x = 0; if (x > rect.width) x = rect.width;
                if (y < 0) y = 0; if (y > rect.height) y = rect.height;
                
                this.picker.s = Math.round((x / rect.width) * 100);
                this.picker.v = Math.round(100 - (y / rect.height) * 100);
            },
            
            selectPickerColor() {
                this.setColor(this.tempColor);
                this.showColorPicker = false;
            }
        }
    }).mount('#app');
</script>
<script type="module" src="/index.tsx"></script>
</body>
</html>